# 2. 전자 계산기

## 1. 순서 논리 회로
* 입력과 내부 상태의 조합에 의해 출력이 결정되는 회로이다.
* 플립플롭이나 레지스터 장치로 구성되는 회로이다.
* 기억 능력을 갖추고 있다.
* 비동기식 동작
    * 신호가 입력 되면 곧바로 동작한다.
* 동기식 동작
    * 클럭 펄스에 맞춰 동작한다.                
* 플립플롭, 카운터, 레지스터, RAM, ROM, CPU 등이 있다.
    * 플립플롭
        * 전원이 공급되는 한 현재의 상태를 유지한다.
        * 순서 논리 회로를 구성하는 기본 기억 소자
        * 1비트를 기억할 수 있는 2진 Cell 이다.
        * RS 플립플롭 
            * S R
            * 0 0: 상태 변화 없음
            * 1 0: 1
            * 0 1: 0
            * 1 1: 불허
        * JK 플립플롭
            * J K
            * 1 1: 상태 반전
        * D 플립플롭
            * RS, JK 플립플롭에서 서로 배타적인 경우만 이용되도록 고안된 플립플롭이다.
            * 즉, S가 0이면 R은 1이되고, S가 1이면 R은 0이 되도록 고안한 플립플롭이다.
    * 레지스터
        * 외부로부터 들어오는 데이터를 저장하거나 이동하는 목적으로 사용
        * 플립플롭 여러개가 하나의 묶음으로 작동할 때, 이 묶음을 레지스터라고 한다.
            * 시프트 레지스터
                * 매 클럭 주기로 모든 비트를 한 자리씩 옮기게 하는 레지스터이다.
            * 병렬 시프트 레지스터
                * n개으 비트로 구성된 레지스터의 내용을 연결된 다른 레지스터로 한 번에 이동시킬 수 있는 레지스터이다.
            * 직렬 입력 레지스터
                * 데이터를 직렬로 즉, 하나의 라인에서 한 번의 비트씩 받아들인다.
                * 직렬 출력 레지스터
                    * 회로가 간단하다.
                    * 장거리 전송에 사용된다.
                    * 속도는 떨어진다.
                * 병렬 출력 레지스터  
                    * 회로가 복잡하다.
                    * 속도가 빠르다.
                    * 단거리 전송에 사용된다.
    * 카운터
        * 매 입력 펄스 마다 미리 정해진 순서대로 상태가 변하는 순서 논리 회로이다.    
        * 클럭 펄스의 개수를 처리하기 위한 논리회로이다.
            * 종류
                * 리플 카운터 
                    * 비동기식 카운터이다.
                    * 첫 번째 플립플롭의 CP(Clock Pulse) 입력에만 클럭 펄스가 입력된다.
                    * 다른 플립플롭은 각 플립플롭의 출력을 다음 플립플롭의 CP 입력으로 사용된다.
                    * 회로가 간단하지만 전달지연이 커진다.
                * 병렬 카운터
                    * 동기식 카운터이다.
                    * 입력 클록 펄스에 모든 플립플롭이 동시에(병렬로) 동기화된다.
## 2. 코드
* 가중치 코드
    * 8421
        * 4비트(8, 4, 2, 1)의 가중 값을 갖는 가중치 코드이다.
        * 10~15까지는 사용하지 않는다
* 비가중치 커드
    * 3초과 코드
        * 8421 코드를 3초과 시켜 만든 코드이다.
        * 3초과 코드는 앞에서 3개, 뒤에서 3개를 사용하지 않는다.
        * 자기보수코드
            * 비트를 반전하는 것 만으로도 9의 보수를 얻을 수 있다. (감산에 유리)
    * 그레이 코드
        * 한 비트의 변화만으로 다음 값을 만들 수 있기 때문에 변화가 작다.
        * 입, 출력 장치, A/D 변환기에 유리하다
        * 연산 사용에는 부적합하다.
* 오류 검출 코드
    * 패리티 비트
        * 정보 전달 과정에서 오류가 났는지 검사하기 위해 추가된 비트이다.
        * 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송하는 방법으로, 1개의 비트 오류만을 검출할 수 있다.
        * 수정은 할 수 없다.
    * 해밍 코드
        * https://eastroot1590.tistory.com/entry/%EC%98%A4%EB%A5%98-%EA%B2%80%EC%B6%9C-%EC%BD%94%EB%93%9C-%ED%95%B4%EB%B0%8D%EC%BD%94%EB%93%9CHamming-Code
        
## 3. 명령어(Instruction)
* 명령어의 설계
    * 여러 동작을 실행하는데 필요한 정보를 가지고 있으며, 모든 컴퓨터에서 기본적으로 수행될 연산자와 그 연산에 사용될 대상체로 구성된다.
        * 연산자(Op-Code)
            * 컴퓨터가 행하는 동작을 기호하 해서 나타낸 정보.
        * 모드
            * 대상체를 지정하는 방법이다.
            * 직접 주소와 간접 주소가 있다.
        * 주소
            * 처리된 정보 또는 처리할 정보를 표시하는 부분이다.
            * 기억 장소의 주소, 레지스터의 번호, 사용할 데이터 등을 표시한다.
            * 주소부의 크기는 메모리 용량과 관련있다.
* 명령어의 종류
    * 데이터 처리 명령어
        * 자료에 대한 연산 능령을 컴퓨터에 부여하는 명령어
        * 종류
            * 산술 연산
                * ADD, SUB, MUL, DIV
                    * 더하기, 빼기, 곱하기, 나누기
                * INC
                    * 1 증가시키는 명령
                * DEC
                    * 1 감소시키는 명령
            * 논리 연산
                * AND
                    * 특정 문자 삭제 시 사용
                * OR
                    * 특정 문자 삽입 시 사용
                * XOR
                    * 비교 시나 부분 반전 시 사용
                * COMPLEMENT
                    * 1의 보수를 구할 때 사용
                * CLEAR
                    * 모든 내용을 0으로 리셋할 때 사용
            * 시프트 연산
                * 산술 Shift
                    * 2로 곱하거나 나누기를 하기 위한 오른쪽이나 왼쪽으로의 이동 명령
                * 논리 Shift
                    * 자료를 오른쪽이나 왼쪽으로 이동시키기 위한 명령
                * Rotate
                    * 문자의 위치 변환을 위한 이동 명령(ROL, ROR)
    * 데이터의 전송 명령
        * 자료의 변경 없이 한 장소에서 다른 장소로 전송시키는 명령어
        * 메모리와 레지스터, 레지스터와 레지스터, 메모리와 입출력장치 사이의 데이터 전송이 있다.
        * 종류
            * LOAD
                * 메모리로부터 CPU의 레지스터로 자료를 가져오는 명령
            * STORE
                * CPU의 레지스터에 있는 자료를 메모리에 기억시키는 명령                   
            * MOVE
                * 레지스터에서 레지스터로 데이터를 전달하는 명령
            * PUSH, POP
                * 스택에 데이터를 입출력하는 명령
            * INPUT
                * 입력 장치에 있는 데이터를 메모리로 전달
            * OUTPUT
                * 메모리에 있는 데이터를 출력 장치로 전달
    * 데이터 제어 명령
        * 모든 명렁어들이 상황에 맞게 적절히 수행될 수 있도록 조작을 가하는 것
        * 종류
            * JUMP
                * 원하는 곳으로 무조건 분기
            * SKIP
                * 다음 명령어를 건너뛰고 수행
            * SMA
                * ACC가 0보다 작을 때 스킵
            * SZA
                * ACC가 0과 같을 때 스킵
            * SZC
                * C가 0과 같을때 스킵
            * ISZ
                * 1 증가하여 0과 같으면 스킵
            * RETI
                * 인터럽트로부터 복귀
            * CALL
                * 서브 프로그램의 호출
            * RETURN
                * 서브 프로그램에서 메인 프로그램으로 복귀
            * HALT
                * 컴퓨터의 동작을 일시적으로 정지시킴
    * 기타 명령
        * 리커션
            * 자기가 자신을 호출하는 경우
            * 되돌아올 복귀 주소를 스탹에 Push하고 다시 자신을 실행하는 것이다.
        * 반복
        * 매크로
            * 반복되는 일련의 루틴을 별도로 작성해 놓음
            * 본문 자체에 삽입되어 사용된다.
            * 자주 사용하는 여러 개의 명령어를 묶어서 하나의 명령어로 만드는 것이다.
        * 부 프로그램
            * 반복되는 일련의 루틴을 별도로 작성해 놓음
            * CALL 문으로 호출해 사용한다
* 명령어의 형식
    * 0-주소 명령어 형식
        * 스택에 있는 데이터를 사용한다.
        * 명령어만 있고 주소는 없다.
        * 모든 연산은 스택상에 있는 두 값을 묵시적으로 지정하여 POP해서 연산을 수행하고 결과를 다시 스택에 PUSH한다.
        * 원래의 데이터는 모두 잃어버린다.
    * 1-주소 명령어 형식
        * 누산기에 있는 데이터를 사용한다.
        * 명령어와 1개의 주소로 구성된 명령어 형식이다.
        * 연산 시 두개의 자료 중 하나는 묵시적으로 누산기를 지정하여 연산하고, 연산 결과 역시 누산기에 저장한다.
    * 2-주소 명령어 형식
        * 레지스터에 있는 데이터를 사용한다.
        * 명령어와 2개의 주소로 구성된 명령어 형식이다.
        * 연산 후 결과가 Operand-1에 저장되므로 Operand-1의 위치에 있던 원래의 내용은 잃어버리게 된다.
        * 계산 결과를 시험할 필요가 있을 때 계산 결과가 기억 장치에 기억될 뿐 아니라 중앙 처리 장치에도 남아 있어서 중앙 처리 장치 내에서 직접 시험이 가능하다.
    * 3-주소 명령어 형식
        * 메모리에 있는 데이터를 사용한다.
        * 명령어와 3개의 주소로 구성된 명령어 형식이다.
        * 연산 시 두 개의 자료는 Operand-1과 Operand-2에서 지정된 2개의 자료를 대상으로 연산하고, 연산 결과는 Operand-3에 저장된다.
        * 원래의 내용 모두 보존 가능하다.
        * 명령어의 길이가 길다.
* 명령어의 수행 순서
    * 명령어 인출 -> 명령어 해독 -> 오퍼랜드 인출 -> 실행 -> 인터럽트 조사
    * 명령어 인출 과정에서 인터럽트가 발생하더라도 CPU는 인터럽트를 인지하지 못한다.
* CPU Clock
    * CPU의 순서 동작을 동기화 하기 위한 펄스
    * 마이크로 사이클 타임은 CPU Click의 발생 주기와 동기화 해주어야 한다.        
* 마이크로 오퍼레이션
    * CPU에서 발생시키는 하나의 클록 펄스 동안 실행되는 기본 동작을 의미한다.
    * 명령어를 수행하기 위해 CPU에 있는 레지스터와 플래그의 의미 있는 상태 변환을 일으키게 하는 동작이다.
    * CU의 제어 신호에 따라 마이크로 오퍼레이션이 순서적으로 일어난다.
    * 여러 단계의 마이크로 오퍼레이션을 통해 하나의 명령어가 수행된다.
* 마이크로 사이클 시간
    * 하나의 오퍼레이션을 수행하는 과정이다.
    * 마이크로 연산을 수행하는데 걸리는 시간이다.
    * CPU Clock Time 또는 CPU Cycle Time으로 부르기도 한다.
    * 방식
        * 동기 고정식
            * 마이크로 사이클 시간을 여러 개의 마이크로 오퍼레이션 동작 중에서 가장 긴 시간으로 지정하는 방식이다.
            * CPU의 시간 이용이 비효율적이다.
            * 모든 마이크로 오퍼레이션의 수행 시간이 유사한 경우에 사용한다.
            * 구현이 간단하다.
        * 동기 가변식
            * 마이크로 사이클 시간을 마이크로 오퍼레이션 동작들을 마이크로 사이클 타임에 따라 몇 개의 군으로 분류하여 군별로 지정하는 방식이다.
            * 마이크로 오퍼레이션 수향 시간의 차이가 현저할 때 사용한다.
        * 비동기식
            * 모든 마이크로 오퍼레이션에 대해 서로 다른 마이크로 사이클 시간을 부여하는 방법이다.
            * 이 경우는 하나의 오퍼레이션 동작이 끝나면 끝난 사실을 제어 장치에 알려 다음 오퍼레이션이 수행되도록 하여야 하므로 제어 장치가 복잡하게 된다.
* 메이저 상태
    * Cycle Time을 단위로 하여 해당 주기 동안에 기억 장치로 접근할 때 무엇을 위해 접근하는지를 표시한다.
    * CPU가 무엇을 하고 있는가를 나타내는 상태이다.        
    * Fetch, Excute, Indirect, Interrupt 상태가 있다.
    * 이 상태는 F, R 플래그의 상태를 가지고 파악한다.
    * 인출 주기가 완료되면 해독 결과에 따라 직접 주소이면 바로 실행 주기로 진행하고, 간접 주소이면 간접 주기를 거쳐서 실행 주기로 진행된다.
    * 실행 주기에서는 인터럽트 발생 여부에 따라 인터럽트가 발생했으면 인터럽트 주기로 진행하고 그렇지 않으면 인출 주기로 진행된다.
    * 인터럽트 주기에서는 항상 인출 주기로 진행된다.
        * 인출 주기 (F:0/R:0)
            * 명령어를 기억 장치에서 중앙 처리 장치로 읽어오는 주기이다.
            * 명령어를 해독하는 주기이다.
            * PC가 하나 증가되어 다음 명령어를 지시하는 주기이다.
        * 간접 주기 (F:0/R:1)
            * 유효 주소를 얻기 위해 기억 장치에 한 번 더 접근하는 주기이다.
            * 오퍼랜드에 표현된 주소가 간접 주소인 경우에 수행되는 주기이다.
        * 실행 주기 (F:1/R:0)
            * 기억 장치로부터 실제 데이터를 읽어다가 연산 동작을 수행시키는 주기이다.
            * 다양한 형태의 명령어가 분기 처리되는 주기이다.
                * ADD 
                    * ACC(누산기) 에 있는 내용과 메모리에 있는 내용을 더해서 결과를 ACC에 넣어놓는 연산이다.
                    * MAR <- MBR(AD) 
                    * MBR <- M 
                    * ACC <- ACC + MBR
                    * F <- 0, R <- 0
                * AND
                    * ACC에 있는 내용과 메모리에 있는 내용을 논리곱하여 결과를 누산기에 넣어놓는 연산이다.
                    * MAR <- MBR(AD)
                    * MBR <- M
                    * ACC <- ACC ^ MBR
                    * F <- 0, R <- 0
                * LOAD(LDA)
                    * ACC를 0으로 초기화하고, 이 초기화된 누산기와 메모리에 있는 내용을 더해서 결과를 누산기에 넣어놓게 되면 메모리에 있는 내용을 누산기로 이동시킨 효과를 보게 된다.
                    * MAR <- MBR(AD)
                    * MBR <- M, ACC <- 0
                    * ACC <- MBR
                    * F <- 0, R <- 0
                * STORE(STA)
                    * ACC에 있는 내용을 지정된 메모리에 저장시키는 연산이다.
                    * MAR <- MBR(AD)
                    * MBR <- ACC
                    * M <- MBR
                    * F <-, R <- 0
                * BUN(JUMP)
                    * 프로그램의 수행 제어 순서를 지정된 유효 번지로 분기시키는 명령어이다.
                    * PC <- MBR(AD)
                    * 동작 없음
                    * 동작 없음
                    * F <- 0, S <- 0
        * 인터럽트 주기 (F:1/R:1)
            * 여러 가지 원인에 의해서 정상적으로 수행 과정이 불가능 할 때 CPU의 현 상태를 보관하기 위해 기억 장치에 접근하는 주기이다.
            * 명령어 수행 과정에서 인터럽트가 발생 하더라도 반드시 해당 명령어가 완료된 상태에서 인터럽트를 처리하게 된다.
            * 방식
                * PC값을 메모리의의 0번지에 저정할 때
                    * MBR(AD) <- PC, PC <- 0
                    * MAR <- PC, PC <- PC + 1
                    * M <- MBR, IEN <- 0
                    * F <- 0, R <- 0
                   

## 4. 주소 지정 방식
* 즉시 주소
    * 명령어의 주소 부분에 실제 데이터가 들어가 있는 방식이다,
    * 명령어 수행이 즉각적으로 이루어진다.
    * 메모리를 참조할 필요가 없다.
    * 명령어에 실제 데이터를 포함하고 있으므로 수행 속도는 빠르지만 Operand에 실제 데이터를 넣기 위해서는 명령어 길이에 제약이 따를 수 밖에 없다.
* 직접 주소
    * 명령어의 주소 부분에 데이터를 기억하고 있는 기억 장소의 주소를 지정하는 방식이다,
    * 실제 데이터를 가져오기 위해 메모리는 한 번만 참조하면 된다.
    * 단순한 대신에 융통성이 조금 떨어진다.
* 간접 주소
    * 명령어의 주소 부분이 지정하는 메모리 번지에 실제 데이터의 주소가 지정되는 방식이다.
    * 실제 데이터를 가져오기 위해 메모리를 두 번 이상 참조해야 된다.
    * 명령어의 길이가 짧고 제한되어 있어도 이것을 이용하여 긴 주소를 찾아갈 수 있기 때문에 주소 지정에 많은 융통성이 있다.
* 계산에 의한 주소
    * Operand 부분에 있는 주소 값에 임의의 상수 값이나 레지스터에 있는 값을 더해서 유효 주소를 결정하는 방법이다.
    * 인덱스 주소 지정
        * Operand 부분에 있는 주소 값과 인덱스 레지스터에 들어있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식이다.
        * 배열 엑세스 방식에 많이 사용된다.
    * 상대 주소 지정
        * Operand 부분에 있는 주소 값과 PC에 들어 있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식이다.
        * 데이터 영역의 배치와 프로그램 영역의 배치가 유사한 경우에 많이 사용한다.
        * 분기 명령에 많이 사용한다.
    * 기준 주소 지정
        * Operand 부분에 있는 주소 값과 베이스 레지스터에 들어있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지장하는 방식이다.
        * 프로그램의 재배치를 하는 경우에 상대적인 변위 지정만으로 해당 위치를 지정하기 위해 많이 사용된다.
        * 다중 프로그래밍 기법에서 많이 사용된다.
* 묵시적 주소
    * 0 주소 명령어나 1 주소 명령어 형식에서 스택이나 누산기의 위치를 지정할 때는 명시적으로 지정하는 것이 아니라 묵시적으로 가르키게 되는데, 이 경우를 의미한다.
* 레지스터 주소
    * Operand에 레지스터의 위치를 지정하는 방식이다.

## 5. 중앙처리장치(CPU)
* 컴퓨터 시스템에서 가장 중요한 일을 하는 부분이다.
* 프로그램을 수행하는 장치
* 명령어를 수행하며, 그 명령어의 수행 순서를 제어하는 기능을 가지고 있다.
* 중앙 처리 장치의 구성 (연산장치, 레지스터, 제어장치)
    * 연산 장치(ALU)
        * 산술 및 논리 연산등을 수행하는 장치이다.
        * 가산기, 누산기, 자리 올림 플립플롭, 오버플로 체크 플립플롭, 보수기 둥으로 구성되어 있다.   
    * 레지스터
        * 중앙 처리 장치 안에 있는 임시기억 장치이다. (외부에도 있을 수도 있다.)      
        * 주기억 장치보다 작은 개수의 주소 비트를 가진다.
        * 컴퓨터 프로세서 내에서 자료를 보관하는 아주 빠른 기억 장소이다.
        * 일반적으로 현재 계산을 수행중인 값을 저장하는데 사용된다.
        * 현대 프로세서는 메인 메모리에서 레지스터로 데이터를 옮겨와 데이터를 처리한 후 그 내용을 다시 레지스터에서 메인 메모리로저장하는 로드-스토어 설계를 사용하고 있다.
            * 종류        
                * Memory Address Register
                    * 외부 메모리에 쓰거나 읽을 때, Data가 들어 있는 주소를 가르키는 값을 넣어두는 레지스터이다.
                    * 주소 버스와 연결되어 있다.
                    * 메모리에 접근하고자 할 때 접근하고자 하는 곳의 주소 값을 기억하고 있는 레지스터이다.
                    * 기억 장치의 용량과 관계 있는 레지스터이다.
                * Memory Buffer Register
                    * 주기억 장치에서 정보를 읽을 때 읽은 정보를 기억시키거나 주기억 장치에 정보를 기억시키는 레지스터이다.
                    * 기억 장치의 WORD 크기와 관계가 있다.
                    * 외부 메모리에서 읽어온 값을 임시 저장하는 레지스터이다.
                    * 데이터 버스와 연결되어 있다.
                    * 따라서 메모리의 용량은 AR과 관계있고, 한 번에 액세스 되는 워드 크기는 DR과 관계 있다.
                    * ex) 컴퓨터의 메모리 용량이 16K x 32Bit
                        * AR) 16K =  16 x 10K => 2^4 x 2^10 = 2^14 => 14비트
                        * DR) 32비트
                * Instruction Register
                    * 외부 메모리에서 읽어온 Op-Code를 저장하는 레지스터이다.
                * Program Counter
                    * 다음 명령어의 주소 값을 기억하고 있는 레지스터이다.
                    * 명령어의 수행 순서를 나타내는 레지스터이다.
                    * 이 레지스터가 없다면 각 명령어 마다 다음에 수행하여야 할 명령어에 대한 주소 값을 기억하고 있어야 한다.
                * ACCumulator
                    * 연산 기능 수행 시 중심이 되는 데이터 레지스터이다.
                    * 연산 장치에 연결되어 있다.
                    * 연산시 연산에 사용되는 데이터 및 연산 결과를 임시적으로 기억한다.
                * Index Register
                    * 주소 변환 및 계산에 필요한 수를 기억한다.
                    * 주소 수정에 필요한 주소 값을 기억한다.
                    * 배열의 시작 주소와 같은 반복 계수를 기억시키는 요소로 사용한다.
                * Base Register
                    * 하나의 서브 프로그램 루틴 또는 데이터의 블록에 대하여 기준이 되는 주소를 기억시키는 레지스터이다.
                    * 프로그램을 재배치하는 경우 상대적은 변위 값을 기억시키는데 사용된다.
                    * 명령이 시작되는 최초의 번지를 기억한다.
                * Flag Register
                    * 프로그램의 수행이 진행되고 있을 때 매 순간마다 프로그램의 수행 상태를 포함하는 중앙 처리 장치의 상태를 나타내는 레지스터이다.
                    * 명령의 실행 중에 어떤 상황(부호 체크, 오버플로 여부, 캐리 발생 여부 등) 발생에 대한 사항들을 각각 1비트로 세트시키는 레지스터를 의미한다.
                * Major State Register
                    * CPU가 무엇을 하고 있는지 나타내는 레지스터이다.
                * Stack Poninter
                    * 현재 사용하고 있는 Stack 영역에서 마지막 데이터가 push 된 곳의 주소를 가리킨다.
                * Linked Register
                    * 방금까지 수행하다가 jump를 했을 경우, 돌아갈 곳의 주소를 가리킨다.         
    * 제어 장치(CU: Control Unit)
        * 주기억 장치에 기억되어 있는 명령어를 차례로 인출하여 해독하고, 해독한 결과에 따라 필요한 제어 신호를 각 장치에 보내는 역할을 한다.
        * 입출력 장치 간 통신 및 조율을 제어한다.
        * 타이밍과 제어 신호들을 제공함으로써 다른 장치들의 조작을 지시한다.
        * 모든 컴퓨터 자원들은 제어 장치의 관리를 받는다.
        * 중앙 처리 장치와 다른 장치들 사이의 데이터 흐름을 제어한다.
            * 구성
                * 명령어 해독기 (Instruction Decoder)
                    * 명령 레지스터(IR)로 들어온 Op-Code를 해독하고 해독한 Op-Code의 연산을 위해 CM상의 시작 주소를 결정하는 회로이다.
                * 제어 주소 레지스터 (CAR)
                    * 다음에 실행할 마이크로명령어의 주소를 저장하는 레지스터이다.
                    * CM내의 특정 위치를 카리킨다.
                * 서브 루틴 레지스터 (SBR)
                    * 마이크로 프로그램에서 서브루틴이 호출되는 경우 현재의 CAR을 일시적으로 저장하는 레지스터
                * 제어 메모리 (CM)
                    * 마이크로 인스트럭션들로 이루어진 마이크로 프로그램을 저장하는 내부 기억 장치이다.
                * 제어 버퍼 레지스터 (CBR)
                    * CM에서 읽은 마이크로 명령어를 일시적으로 기억하는 레지스터이다.
                * 시퀀싱 모듈
                    * 마이크로 명령어의 실행 순서를 결정하는 장치이다.
        * 제어 장치의 구현 방법
            * 고정 배선식 제어 방식
                * 제어 장치가 순서 회로로 만들어진 것이다.
                * 미리 정해 놓은 제어 신호들이 순서대로 발생되도록 하드웨어적으로 구현한 방식이다.
                * 마이크로프로그램 제어 방식보다 속도가 빠르다.
                * 한 번 만들어진 것은 동작 방법이 바뀌었을 때 변경할 수 없다.
            * 마이크로프로그램 제어 방식
                * 마이크로 명령어로 구성하여 작성하므로 쉽게 설계를 바꿀 수 있다.
                * 마이크로 명령어를 인출하는 별도의 시간이 존재하기 때문에 속도가 느리다.
                * 마이크로프로그램을 저장하기 위한 제어 메모리가 필요하다.
    
## 6. 버스
* CPU에서 각 부분의 정보 교환은 Address Bus와 Data Bus를 통하여 이루어진다.
* 주소 버스
    * 메모리의 특정 위치를 지정하기 위한 단방향 신호 회선으로 신호선의 수는 메모리의 용량과 관계가 있다.
    * 즉, 메모리 용량이 128K이면 어드레스 버스선의 수는 2^7 x 2^10 = 17bit이다.
* 데이터 버스
    * CPU와 주기억 장치 사이에서 데이터를 주고받기 위한 양방향 회선이다.
    * CPU가 한 번에 처리할 수 있는 bit수이다.
* 제어 버스
    * CPU나 메모리 혹은 입출력 장치에 어떤 동작을 취하게 하기 위해 제어 신호를 전달하는 단방향 신호 회선이다.

## 7. 주기억 장치
* CPU가 직접 사용할 수 있는 기억장소이다.
* 시스템 프로그램 영역과 사용적 프로그램 영역으로 나누어 사용된다.
* 비교적 빠르고 큰 메모리이다.
* 기억 장소와 관계 없이 접근 시간이 일정하다.
* 수행 중인 프로그램을 저장하는데 사용한다.
* 수행 중인 프로그램이 사용할 데이터를 저장하는데 사용한다.
* 버퍼 메모리
    * CPU와 주기억 장치 사이에서 데이터를 주기억 장치에서 읽어내거나, 주기억 장치에 저장하기 위해 임시로 자료를 기억시키는 캐시와 CPU와 입출력 장치 사이의 속도 차이를 줄이기 위해 주기억 장치의 일부를 사용하는 입출력 버퍼이다.
* RAM
    * RAM은 전원 공급이 되지 않으면 기억된 정보가 사라지는 휘발성 메모리이다.
* ROM
    * 비휘발성 메모리로 읽기만 가능하기 때문에 ROM의 내용을 임의로 변경할 수 없다.
    * 제어용 프로그램(마이크로프로그램) 또는 모니터 프로그램 등을 고정 시켜 사용한다.

## 8. 캐시 기억 장치
* CPU와 주기억 장치의 속도 차이를 극복하기 위해 CPU와 주기억 장치 사이에 설치한 메모리이다.
* CPU와 비슷한 액세스 속도를 가지고 있다.
* 미리 데이터를 옮겨 놓고 버퍼 개념으로 사용하는 기억 장치이다.
* CPU에서 실행 중인 프로그램과 데이터를 기억한다.

## 9. 연관 기억 장치
* 기억 장치 접근 시 주소에 의해 찾아가는 것이 아니라 찾고자 하는 내용 일부를 가지고 원하는 내용을 찾아 그 위치의 내용 모두를 제공하는 원리의 기억 장치이다.
* 주소를 필요로 하지 않는다.
* 정보 검색에 유용하다.
* 병렬 판독 회로를 내장하고 있기 때문에 가격이 비싸다.
* 캐시 메모리보다 빠르다.

## 10. 가상 기억 장치
* 기억 용량을 효과적으로 이용하기 위해 주기억 장치보다 훨씬 큰 보조 기억 공간을 주기억 장치의 연속된 기억 공간으로 사용하는 방식이다.
* 주소 공간의 확대가 목적이다.
* 보조 공간 전체를 주소 공간으로 보고 명령어를 만드는 방식이다.
* 소프트웨어로 구현된다.
* 보조 기억 장치는 직접 접근 장치여야 한다.
* 가상 주소를 실제 주소로 변환하는 과정이 필요하다.
    * 용어
        * 사상
            * 가상 기억 장치에 있는 내용을 어떤 일정한 단위로 분류하여 이 단위의 내용이 실기억 장치의 어느 위치에 있는지를 알아내는 방법
        * 페이징
            * 가상 기억 장치에 있는 내용을 어떤 일정한 단위로 분류할 떄 분류 단위가 똑같으면 페이징 이라고 한다.
        * 페이지 폴트
            * 주기억 장치에 없는 페이지가 참조될 떄 생기는 인터럽트이다.
            * 페이지 폴트가 발생하면 CPU는 하던 일을 중단하고 해당 페이지를 주기억 장치로 옮겨 놓은 후 다시 인터럽트를 처리한다.
        * 스태깅
            * 가상 기억 체제에서 페이지 폴트가 발생히면 희생 페이지를 결정해서 보조 기억 장치의 이전 위치에 기억 시키고 새로운 페이지를 희생된 페이지가 있던 곳에 위치시키는 과정을 의미한다.
        * 스레싱
            * 보조 기억 장치의 페이지 접근 횟수가 많아 작업 수행 시간보다 페이징 교체 시간이 많아지는 경우를 의미한다.

## 11. 인터럽트
* 중앙 처리 장치와 주변 장치의 차이에 따른 효율적인 시스템 자원의 활용과 기계적 장애로 인하여 실행하던 프로그램을 완료하지 못하였을 떄, 처음부터 다시 하지 않고 중단된 위치로 복귀되어 이상 없이 계속 프로그램이 진행되도록 한다.
* 동작 순서
    * 인터럽트 요청
        * 인터럽트 발생 장치로부터 인터럽트 기능을 요청한다.
        * 컴퓨터 내의 자원들이 인터럽트 요청 회선을 통하여 CPU에 요청 신호를 전달한다.
        * 종류
            * 단일 인터럽트 신호 요청 회선(폴드 인터럽트 방식)
                * 인터럽트 요청이 가능한 장치를 CPU와 단일 회선으로 연결한 방식이다.
                * 인터럽트를 요청한 장치 판별 과정이 필요하다.
                * 복귀 주소인 PC값을 메모리 0 번지나 스택에 저장한다.
                * 인터럽트 요구가 있는 장치를 찾기 위해 하나 하나 찾아가 검색하는 방식으로 느리다.
            * 고유 인터럽트 신호 요청 회선(벡터 인터럽트 방식)
                * CPU에 있는 인터럽트 레지스터에 각 비트에 고유 회선을 연결하는 방식이다.
                * 하드웨어 신호가 발생하면 인터럽트 서비스 루틴으로 분기하는 명령들로 구성된 인터럽트 벡터를 이용하여 바로 인터럽트 서비스 루틴을 실행시킨다.
                * 장치마다 고유한 인터럽트 요청 신호 회선을 가지므로 인터럽트를 요청한 장치 판별 과정이 필요 없다.
    * 현 상태 보존
        * 현재 실행중이던 프로그램의 상태를 안전한 장소에 보관한다.
    * 인터럽트 판별
        * 인지 신호를 발생시켜 인터럽트의 원인을 판별하고 그것을 처리하는 인터럽트 서비스 루틴을 시작시킨다.
    * 인터럽트 취급
        * 인터럽트 서비스루틴으로 해당 인터럽트에 대한 조치를 취한다.
    * 인터럽트 복귀
        * 인터럽트 요청 시 보관되었던 상태를 이용하여 원래 프로그램이 계속되도록 한다.
* 인터럽트 처리 루틴의 기능
    * 인터럽트를 인지하고 현 상태를 보존한다.
    * 인터럽트 원인을 판별한다.
    * 인터럽트 판별 동안 다른 인터럽트 발생을 방지한다.
    * 해당 인터럽트에 맞게 인터럽트 처리 루틴 시작을 지시한다.
    * 인터럽트 처리가 완료되면 인터럽트 처리 시 보존시켰던 PC 및 제어 상태 데이터를 PC와 제어 상태 레지스터에 복구한다.



    
## 기타
    * 기억 장치의 용량
        * K 2 ^ 10 (천)
        * M 2 ^ 20 (백만)
        * G 2 ^ 30 (10억)
        * T 2 ^ 40 (1조)
    * 입출력 장치
        * 입출력 버스
            * 주기억 장치와 입출력 장치 사이에 정보 교환을 위해 마련되어 있는 통신 회선이다.
        * 입출력 인터페이스
            * 입출력 포트라고도 불린다.
            * 입출력 버스와 입출력 장치 사이의 정보를 전송하는데 필요한 회로이다.

    * DMA (Direct Memory Access)
        * CPU의 개입 없이 직접 주기억 장치와 DMA 사이에서 일련의 입출력 동작이 이루어지는 방식이다.
        * 하나의 입출력 명령에 의해 하나의 블록 전체가 전송된다.
        * 사이클 스틸에 의해 전송이 이루어 진다.
        * 전송이 끝나면 인터럽트를 발생시켜 CPU에게 알려준다.
        * 전송 절차
            * 버스 사용 요구 -> 버스 사용 허가 -> 데아터 전송 -> 인터럽트

    * 채널
        * 채널은 주기억 장치와 입출력 장치 사이에서 입출력을 제어하는 입출력 전용 프로세서이다.












