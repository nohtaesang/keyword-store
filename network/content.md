* URL의 맨 앞 
    * 브라우저는 웹 서버에 액세스하는 클라이언트로 사용하는 경우가 많다.
    * http
    * 하지만, 다른 기능도 많다.
    * ftp->파일 다운/업로드
    * mailto->메일의 클라이언트 기능
    * URL의 맨 앞에 있는 문자열에서 액세스하는 방법을 나타낸다
    * 액세스 대상이 웹 서버라면 http, ...
    * file: -> 클라이언트 PC 자체의 파일에서 데이터를 읽어온다 
    * 이와 같이 반드시 프로토콜을 나타낸다고 할 수는 없다.
    * URL의 맨 앞은 액세스 방법!!


* 브라우저는 먼저 URL을 해독한다.
    * 리퀘스트의 메시지를 작성하기 위해 URL을 해독한다.
    * http: + // + 웹 서버 명 + ( / + 디렉토리명 + / 파일명 ) 생략 가능
    * http: 데이터에 액세스 하는 방법.
    * //는 나중에 이어지는 문자열이 서버의 이름임을 나타냄
    * .com 뒤에 디렉토리가 생략 될 수 있다.
        * 이 경우 대부분의 서버가 index.html이라는 파일 명을 설정해 둔다.
    
* http의 기본 개념
    * http 프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이다.
    * 클라이언트가 서버를 향해 메세지를 보낸다.
    * 메세지 안에는 '무엇을', '어떻게 해서' 하겠다는 내용이 쓰여있다.
        * '무엇을'에 해당하는 것을 URI라고 한다.
            * 보통 페이지 데이터를 저장한 파일의 이름이나 CGI 프로그램의 파일 명을 URI로 쓴다.
            * ex) /dir1/file1.html, /dir1/program1.cgi
            * 그러나 URI는 그것만이 아니라 여기에 http:로 시작하는 URL을 그대로 쓸 수도 있다.
            * 즉 여기에는 다양한 액세스 대상을 쓸 수 있다.
            * 이러한 액세스 대상을 통칭하는 말이 URI이다.
        * '어떻게 해서'에 해당하는 것은 메소드이다.
            * 메소드에 의해 웹 서버에 어떤 동작을 하고 싶은지를 전달한다.
                * ex) URI로 나타낸 데이터를 읽고 싶다, 클라이언트측에서 입력한 데이터를 URI로 나타낸 프로그램에 전달하고 싶다.
                * ex) GET, POST, ...
        * 보충 정보를 나타내는 헤더 파일도 있다.
            * 클라이언트에서 웹 서버에 데이터를 전송할 경우에는 헤더 필드의 뒤에 데이터가 들어간다.
    * 리퀘스트 메시지가 웹 서버에 도착하면 웹 서버는 그 속에 쓰여있는 내용을 해독한다.
    * 그리고 URI와 메시지를 조사하여 '무엇을', '어떻게 하는지' 를 판단 후 요구에 따라 동작한다.
    * 결과 데이터를 응답 메세지에 저장한다.
        * 응답 메세지의 맨 앞부분에는 실행 결과가 정상 종료되었는지, 이상이 발생했는지를 나타내는 스테이터스 코드가 있다.
            * ex) 404 not found,...
        * 그 후 헤더 파일과 페이지의 데이터가 이어진다.
    * 응답 마세지를 클라이언트에 반송한다.
    * 이것이 클라이언트에 도착하여 브라우저가 메시지 안에서 데이터를 추출하여 화면에 표시하면서 HTTP의 동작은 끝난다.

* 메소드
    * GET
        * 웹 서버에 액세스 하여 페이지의 데이터를 읽을 떄 사용한다.
        * 리퀘스트 메시지의 메소드에 'GET'이라고 쓰고, URI에는 '/dir1/file1.html' 과 같이 페이지의 데이터를 저장한 파일의 이름을 쓴다.
        * 이렇게 해서 해당 파일을 읽으라는 의미가 완성된다.
        * 이 메시지가 웹 서버에 도착하면 서버는 해당 파일을 열고 내용의 데이터를 추출한다.
        * 그리고 추출한 데이터를 응답 메세지에 포함해서 클라이언트에게 반송한다.
    * POST
        * 폼에 데이터를 사용해서 웹 서버에 송신하는 경우에 사용된다.
        * URI에는 웹 서버 기계에서 동작하는 애플리케이션 프로그램의 파일명을 쓴다.
        * 'index.cgi'나 'index.php'라는 파일명이 대표적이다.
        * 그리고 리퀘스트 메시지 안에는 메시지와 URI와 더불어 CGI 프로그램이나 스크립트에 건네주는 데이터를 넣는다.
        * 이 데이터는 사용자가 필드에 입력한 값이다.
        * 메시지가 서버 기계에 도착하면 웹 서버 소프트웨어는 URI에 지정된 애플리케이션 프로그램에게 리퀘스트 메시지의 안에 있는 데이터를 건네준다.
        * 그리고 이 프로그램이 출력하는 데이터를 받아서 응답 메시지에 포함시킨 후 클라이언트에게 반송한다.
    * 이 두가지가 HTTP의 대표적인 사용법이다.
    * 인터넷에서 이것들 이외에 메소드를 사용하는 예는 거의 없다.

* HTTP Request message
    * URL을 해독하고 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP Request message를 만든다.
    * 실제 HTTP 메시지를 쓰는 방법, 즉 포맷이 결정되어 있으므로 브라우저는 이 포맷에 맞게 리퀘스트 메시지를 만든다.
    * 첫 번째 행 (리퀘스트 라인)
        * 첫 번째 행에 있는 리퀘스트 라인을 쓴다.
        * 이 행에서 중요한 것은 맨 앞에 있는 메소드이다.
        * 이것을 통해 웹 브라우저는 웹 서버에 어떻게 할 것인지를 전달한다.
        * 메소드를 썼으면 한 칸 띄운 다음에 URI를 쓴다.
        * URI 부분에는 보통 /<디렉토리명>/.../<파일명> 을 쓰는 것이 일반적이다.
        * URL에서 경로를 추출하여 복사한다.
        * 그리고 첫 번째 행의 끝에 메시지가 http의 어느 버전의 사양을 바탕으로 쓴 것인지를 나타내기 위해 버전 번호를 써서 첫 번째 행을 완료한다.
    * 두 번째 행 이후 (메시지 헤더)
        * 메시지 헤더라는 행이 이어진다.
        * 첫 번째 행에서 리퀘스트의 내용을 대략 알 수 있지만, 부가적인 자세한 정보가 필요한 경우도 있다.
        * 이것을 써 두는 것이 메시지 헤더의 역할이다.
        * 날짜, 클라이언트측이 취급하는 데이터의 종류, 언어, 압축형식, 클라이언트나 서버의 소프트웨어 명칭과 버전, 데이터의 유효 기간이나 최종 변경 일시 등 다수의 항목이 사양으로 정해져 있다.
        * 메세지 헤더에 쓰는 내용은 브라우저의 종류나 버전, 설정등에 따라 달라진다.
        * 몇 행에서 열 줄 이상의 메시지 헤더를 쓰는 경우가 많다.
    * 그 다음 (메시지 본문)
        * 메시지 헤더르 쓰면 그 뒤에 아무 것도 쓰지 않은 하나의 공백 행을 넣고, 그 뒤에 송신할 데이터를 쓴다.
        * 이 부분을 메시지 본문 이라고 한다.
        * 메시지의 실제 내용이다.
        * 단 메소드가 GET인 경우에는 메소드와 uri만으로 웹 서버가 무엇을 할지 판단할 수 있으므로 메시지 본문에 쓰는 송신 데이터는 아무 것도 없다.
        * 따라서 메시지 헤더가 끝난 곳에서 메시지는 끝난다.
        * 메시지가 post 인 경우에는 폼에 입력한 데이터등을 메시지 본문 부분에 쓴다.
        * 이로써 리퀘스트 메시지 작성 동작이 완료된다.

* 리퀘스트 메시지를 보내면 응답이 돌아온다.
    * 이 메시지를 보내면 웹 서버에서 응답 메시지가 돌아온다.
    * 응답 메시지의 포맷도 기본적인 개념은 리퀘스트 메시지와 같다.
    * <b>그러나 첫 번째 행이 다르다.</b>
    * 응답의 경우는 정상 종료 했는지, 오류가 발생했는지, 즉 리퀘스트의 실행 결과를 나타내는 스테이터스 코드와 응답 문구를 첫 번째 행에 써야 한다.
    * 이들 둘은 내용이 같지만 용도가 다르다.
    * 스테이터스 코드
        * 숫자로 쓴 것이다.
        * 주로 프로그램 등에 실행 결과를 알려주는 것이 목적이다,
            * 1xx
                * 처리의 경과 상황 등을 통지한다.
            * 2xx
                * 정상 종료
            * 3xx
                * 무언가 다른 조치가 필요함을 나타낸다.
            * 4xx
                * 클라이언트측의 오류
            * 5xx
                * 서버측의 오류
    * 응답 문구
        * 문장으로 쓰여있다.
        * 사람에게 실행 결과를 알리는 것이 목적이다.
    * 응답 메세지가 돌아오면, 그때부터 데이터를 추출한 후 화면에 표시하면 웹 페이지를 눈으로 볼 수 있다.
    * 페이지가 문장으로만 되어있으면 이것으로 끝이다.
    * 영상 등이 포함되어 있는 경우에는 계속 내용이 남아 있는다.
        * 영상 등을 포함한 경우에는 문장 안에 영상 파일을 나타내는 태그 라는 제어 정보가 포함되어 있다.
        * 브라우저는 화면에 문장을 표시할 때 태그를 탐색한다.
        * 그리고 영상을 포함하고 있는 의미의 태그를 만나면 그곳에 영상용 공백을 비워두고 문장을 표시한다.
        * 이후 다시 한 번 웹 서버에 액세스 하여 태그에 쓰여있는 영상 파일을 웹 서버에서 읽어와서 방금 전에 비워둔 공백에 표시한다.
        * 이 경우 문장 파일을 읽을 때와 마찬가지로 URI 부분에 영상 파일의 이름을 쓴 리퀘스트 메시지를 만들어 보낸다.
    * 리퀘스트 메시지에 쓰는 URI는 한 개만으로 결정되어 있으므로 파일을 한 번에 한 개씩만 읽을 수 있기 때문에 파일을 따로따로 읽어야 한다.
        * 예를 들면 한 문장에 3개의 영상이 포함되어 있다면, 문장 파일을 읽는 리퀘스트와 영상 파일을 읽는 리퀘스트로, 총 4회 리퀘스트 메시지를 웹 서버에 보낸다.
    * 이렇게 해서 필요한 파일을 판단하고 이것을 읽은 후 레이아웃을 정하여 화면에 표시하는 상태로 전체의 동작을 조정하는 것도 브라우저의 역할이다.
    * 웹서버는 이러한 사정을 모른다.
    * 4회의 리퀘스트가 한 개의 페이지인지, 아니면 별도의 페이지 인지 전혀 신경쓰지 않는다.
    * 단순히 한개의 리퀘스트에 대해 한 개의 응답만 돌려보낼 뿐이다.
    
* IP주소의 용도
    * HTTP의 메세지를 만들면 다음에는 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에 송신한다.
    * 브라우저는 URL을 해독하거나 HTTP 메시지를 만든다.
    * 그러나, 메시지를 네트워크에 송출하는 기능은 없다.
    * 그래서 OS에 의뢰한다.
    * 이떄 URL 안에 쓰여있는 서버의 도메인명에서 IP주소를 조사해야 한다.
    * OS에 송신을 의뢰할 때는 도메인명이 아니라 IP주소로 메시지를 받을 상대를 지정해야 하기 때문이다.

* TCP/IP
    * 인터넷이나 사내 LAN은 TCP/IP의 개념에 기초하여 만들어졌다.
    * TCP/IP는 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어 진다고 생각할 수 있다.
    * 서브넷이란, 허브에 몇 대의 PC가 접속된 것이라고 생각해도 좋다.
    * 이것을 한 개의 단위로 생각하여 서브넷이라고 부른다.
    * 라우터에서 연결하면 네트워크 전체가 완성된다.
    * 서브넷에 네트워크 번호를 할당한다.
    * 컴퓨터에 호스트 번호를 할당한다.
    * 이 두 주소를 합쳐서 IP 주소라고 한다.

* 메시지 운반 과정
    * 액세스 대상의 서버까지 메시지를 운반할 때는 이 IP주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반한다.
    * 송신측이 메시지를 보내면 서브넷 안에 있는 허브가 운반한다.
    * 송신측에서 가장 가까운 라우터까지 도착한다.
    * 그리고 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단한다.
    * 그리고 거기에 보내도록 지시한다.
    * 그 다음 다사 서브넷의 허브가 라우터까지 메시지를 보낸다.
    * 이런 동작의 반복으로 최종적으로 상대의 데이터가 도착한다.

* IP주소의 표기방법
    * 32비트의 디지털 데이터이다.
    * 8비트씩 점으로 구분하여 10진수로 표기한다.
    * 이 형태가 보통 IP 주소이다.
    * 이것만으로는 어느 부분이 네트워크 번호인지 또는 호스트 번호인지 알 수 없다.
    * IP주소의 규칙에서는 네트워크 번호와 호스트 번호의 두 가지를 합쳐서 32비트로 한다는 것만이 결정되어 있을 뿐 내역은 결정되어 있지 않다.
    * 즉 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있다는 것이다.
    * 그러므로 이 내역을 나타내는 정보를 필요에 따라 IP주소에 덧붙인다.
    * 이 정보를 넷마스크 라고 한다.
        * 넷마스크
            * 32비트의 부분이 디지털 데이터로 되어있다,
            * 왼쪽에 1이 나열되고 오른쪽에 0이 나열된 값이 된다.
            * 그리고 넷마스크가 1인 부분이 네트워크 번호를 나타낸다.
            * 0인 부분은 호스트 번호를 나타낸다.
            * 이 넷마스크를 IP주소와 같이 8비트씩 구분하여 표기하고 IP주소의 오른쪽에 병기할 수 있다.
                ex) 10.11.12.13/255.255.255.0
            * 이렇게 표기하면 너무 길어지므로 한 부분의 비트 수를 10진수로 나타내고 IP 주소의 오른쪽에 병기할 수 있다.
                ex) 10.11.12.13/24
            * 두 표기는 방법이 다를 뿐 의미는 같다.
        * 호스트 번호 부분의 비트 값이 모두 0 또는 1인 경우는 특별한 의미를 가진다.
        * 호스트 번호 부분이 모두 0인 IP주소는 각각의 기기를 나타내는 것이 아니라 서브넷 자체를 나타낸다.
        * 호스트 번호 부분이 모두 1이면 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트를 나타낸다.

* 도메인명과 IP주소를 구분하여 사용하는 이유
    * TCP/IP의 네트워크는 IP주소로 통신 상대를 지정하므로 IP 주소를 모르면 상대에게 메시지를 전달할 수 없다.
    * 그러므로 OS에 메시지 송신을 의뢰할 때는 IP 주소를 조사해야 한다.
    * IP주소를 기억하기 어려우므로 서버의 이름을 사용한다.
    * 도메인명을 IP주소로 하면 비효율적이다.
        * IP주소는 32비트 즉, 4바이트
        * 도메인명은 수십 바이트 부터 최대 255바이트
        * 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸릴것이다.
    * DNS를 이용하면 이름으로 IP주소를, IP주소로 이름을 알 수 있다. 

* Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다.
    * IP 주소를 조사하는 방법은 간단하다. 
    * 즉 가장 가까운 DNS 서버에 도메인이름의 서버의 IP주소를 알려달라고 질문하면 된다.
    * 그러면 DNS서버는 IP주소를 알려준다.
    * DNS 서버에 조회한다는 것은 DNS 서버에 조회 메시지를 보내고, 거기에서 반송되는 응답 메시지를 받는다는 것이다.
    * 이것은 DNS서버에 대해 클라이언트로 동작한다고 말할 수 있다.
    * 이 DNS 클라이언트에 해당하는 것을 DNS 리졸버 또는 단순히 리졸버라고 부른다.
    * 그리고 DNS의 원리를 사용하여 IP 주소를 조사하는 것을 네임 리졸루션이라고 한다.
    * 이 리졸루션을 실행하는 것이 리졸버이다.
        * 리졸버
            * 리졸버의 실체는 Socket 라이브러리에 들어있는 부품화한 프로그램이다.
                * Socket 라이브러리
                    * OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 라이브러리이다.
                    * 데이터를 송, 수신할 때 사용하는 부품을 비롯하여 다수의 프로그램 부품들이 들어있다.
            * 브라우저 등의 애플리케이션 프로그램을 만들 때 리졸버의 프로그램명과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있다.
                * ex) const ip = gethostbyname("www.naver.com")
            * 이렇게 해서 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 보낸다.
            * DNS 서버에서 응답이 돌아온다.
            * 이 응답 메시지 속에 IP 주소가 포함되어 있다.
            * 리졸버는 이것을 추출하여 브라우저에서 지정한 메모리 영역에 넣는다.
            * 브라우저가 웹 서버에 메시지를 보낼때는 이 메모리 영역에서 IP 주소를 추출하여 HTTP의 리퀘스트 메시지와 함께 OS에 건네주어 송신을 의뢰한다.
            * 리졸버의 내부 동작
                * 네트워크 애플리케이션(브라우저)이 리졸버를 호출한다
                * 제어가 리졸버의 내부로 넘어간다.
                    * 제어가 넘어간다.
                        * 애플리케이션 프로그램에 쓰여있는 작업 내용은 보통 위에서 아래로 실행된다.
                        * 이것이 리졸버를 호출하는 부분에 이르러 해당 행을 실행하면 여기에서 애플리케이션의 동작이 일시적으로 정지한다.
                        * 그리고 Socket 라이브러리의 내용에 있는 리졸버가 움직이기 시작한다.
                        * 애플리케이션에서 의뢰받은 작업을 실행한다.
                        * 이와 같이 별도의 프로그램을 호출하여 호출처의 프로그램이 쉬고 있는 상태가 되며, 호출한 대상 프로그램이 움직이기 시작하는 것을 '제어가 넘어간다'고 한다.
                * 리졸버에서 제어가 넘어가면 여기에서 DNS 서버에 문의하기 위한 메시지를 만든다.
                * 이것은 브라우저가 웹 서버에 보내는 HTTP의 리퀘스트 메시지를 만드는 것과 유사하다.
                * 메시지를 DNS 서버에 보낸다.
                * 메시지 송신 동작은 리졸버가 스스로 실행하는 것이 아니다.
                * OS의 내부에 포함된 프로토콜 스택을 호출하여 실행을 의뢰한다.
                    * 프로토콜 스택 
                        * OS 내부에 내장된 네트워크 제어용 소프트웨어이다.
                        * 프로토콜 드라이버, TCP/IP 소프트웨어 등으로도 불린다.
                * 리졸버도 브라우저와 같이 네트워크에 대해 데이터를 송, 수신 하는 기능이 없기 때문이다.
                * 리졸버가 프로토콜 스택을 호출하면 제어가 리졸버에게 넘어간다.
                * 여기에서 메시지를 보내는 동작을 실행한다.
                * LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다.
                * 그러면 조회 메시지가 DNS 서버에 도착한다.
                * DNS서버는 메시지에 쓰여있는 조회 내용을 조사하여 답을 찾는다.
                * 액세스 대상의 웹 서버가 DNS 서버에 등록되어 있으면 답이 발견되므로 답을 응답 메시지에 써서 클라이언트에게 반송한다.
                * 그러면 메시지는 네트워크를 통해 클라이언트 측에 도착한다.
                * 프로토콜 스택을 경유하여 리졸버에게 건네준다.
                * 리졸버가 이 내용을 해독한 후 여기에서 IP 주소를 추출하여 애플리케이션에 건네준다.
                * 실제로는 리졸버를 호출할 때 지정한 메모리 영역에 IP 주소를 저장한다.
                * 이로써 리졸버의 동작이 끝나고 제어가 애플리케이션으로 돌아간다.
            * DNS 서버에 메시지를 송신할 때도 DNS 서버의 IP 주소가 필요하다.
            * 단 이것은 TCP/IP 설정 항목의 하나로 컴퓨터에 미리 설정되어 있다.
            * TCP/IP 설정 밥법은 OS의 종류에 따라 다르다.
            * 리졸버는 여기서 설정한 DNS 서버의 IP 주소에 조회 메시지를 보낸다고 생각하면 된다.

* DNS
    * DNS 서버의 기본 동작
        * DNS 서버의 기본 동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.
        * 조회 메시지에는 다음의 세 가지 정보가 포함되어 있습니다.
            * 이름
                * 서버나 메일 배송 목적지(@ 뒷부분)와 같은 이름
            * 클래스
                * DNS의 구조를 고안했을 때 인터넷 이외에도 네트워크에서의 이용 까지 검토하여 이것을 식별하기 위해 클래스라는 정보를 준비했다.
                * 그러나 지금은 인터넷 이외의 네트워크는 소멸되었다.
                * 클래스는 항상 인터넷을 나타내는 'IN'이라는 값이 된다.
            * 타입
                * 이름에 어떤 타입의 정보가 지원되는지를 나타낸다.
                    * 예를 들면 A이면 이름에 IP 주소가 지원되는 것을 나타낸다
                    * MX이면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다.
                * 이 타입에 따라 클라이언트에 회답하는 정보의 내용이 달라진다.
        * DNS 서버에는 이들 세 가지 정보에 대응하여 클라이언트에 회답하는 항목을 등록해 두었다.
        * 이 등록 내용에서 조회 메시지에 해당하는 것을 클라이언트에게 회답한다.
        * 최초에 www로 시작하는 이름을 붙인 것이 많지만, 모두 이런 규칙이 있는 것은 아니다.
        * 최초에 웹의 구조를 만들 때 'www' 이라는 이름으로 웹 서버를 등록한 것이 많았기 때문에 이것이 관례가 된 것 뿐이다.
            * |이름|클래스|타입|클라이언트에 회답하는 항목|
            * |--|--|--|--|
            * |www.naver.con|IN|A|125.209.222.141| 

    * 도메인의 계층
        * 사내 네트워크처럼 웹 서버나 메일 서버의 수가 제한되어 있으면 정보를 전부 한대의 DNS 서버에 등록할 수 있다.
        * 그러나 인터넷에는 막대한 수의 서버가 있으므로 이것을 전부 1대의 DNS 서버에 등록하는 것은 불가능하다.
        * 이를 위해 정보를 분산시켜 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되아 있는지를 찾아내는 구조이다.
        * 우선 DNS 서버에 등록한 정보에는 모든 도메인명이라는 계층적 구조를 가진 이름이 붙여져있다.
        * DNS에서 취급하는 이름은 점으로 구분되어 있는데, 이 점이 계층을 구분한다.
        * 그리고 오른쪽에 위치한 것이 상위의 계층을 나타낸다.
        * 점 으로 구분되는 하나하나를 도메인이라고 부른다.
            * ex) www.naver.com -> com 이라는 도메인 아래 naver 라는 도메인이 있고, 그 아래 www라는 도메인 이있다.
        * 이렇게 계층화된 도메인의 정보를 서버에 등록한다.
        * 이때 하나의 도메인을 일괄적으로 취급한다.
        * 즉, 한 개의 도메인 정보를 일괄적으로 DNS 서버에 등록하고 도메인 한 대의 정보를 분할하여 복수의 DNS 서버에 등록하는 것은 불가능하다.
        * 단 DNS 서버와 도메인은 항상 1 대 1이 아니라 한 대의 DNS 서버에 복수의 도메인의 정보를 등록할 수 있다.
        * 즉, 한 대의 DNS 서버에 도메인 한 대를 등록한다고 생각해도 좋다. 
        * 이제 한 대의 DNS 서버에 도메인 한 대를 등록하는 것으로 가정해보자
        * 그러면 도메인의 계층 구조와 같은 형태로 DNS 서버가 배치된다.
        * 각 도메인의 정보는 그 도메인에 있는 DNS 서버에 등록된다.
    * 담당 DNS 서버를 찾아 IP 주소를 가져온다.
        * 인터넷에슨 DNS 서버가 수만 대나 있으므로 닥치는 대로 뒤지면서 다닐 수는 없다.
        * 먼저 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록한다.
            * ex) www.naver.com 이라는 도메인을 담당하는 DNS 서버를 naver.com의 DNS 서버에 등록한다.
            * naver.com의 DNS 서버를 com의 DNS 서버에 등록한다.
        * 이렇게 하면서 상위의 DNS 서버에 가면 하위의 DNS 서버의 IP 주소를 알 수 있다.
    * 루트 도메인
        * com이나 kr 상위에 존재하는 도메인이다.
        * 루트 도메인에는 도메인명이 없으므로 보통 도메인을 쓸때는 생략한다.
        * 하지만 루트 도메인을 명시적으로 써야 하는 경우에는 www.naver.com. 처럼 끝에 마침표를 찍어서 루트 도메인을 나타낸다.
        * 보통은 그렇게 쓰지 않으므로 루트 도메인의 존재를 알아차리지 못한다.
        * 이 경우 루트 도메인이 존재하므로 DNS 서버에 com, kr의 DNS 서버를 등록한다.
        * 이렇게 해서 하위의 DNS 서버를 상위의 DNS 서버에 등록하여 루트 도메인에서 차례로 아래쪽으로 거슬러 내려갈 수 있다.
        * 등록 작업은 한가지 더 있다.
        * 루트 도메인의 DNS 서버를 인터넷에서 존재하는 DNS 서버에 전부 등록하는 것이다.
        * 이렇게 해서 어느 DNS 서버도 루트 도메인에 엑세스 할 수 있게 된다.
        * 그 결과, 클라이언트에서 어딘가의 DNS 서버에 액세스하면 여기에서부터 루트 도메인을 경유하여 도메인의 계층 아래로 찾아가서 최종적으로 원하는 DNS 서버에 도착하게 된다.
        * 루트 도메인의 DNS 서버에 할당된 IP 주소는 전 세게에 13개 밖에 없고 좀처럼 변경되지 않는다.
        * 따라서 이것을 각 DNS 서버에 등록하는 작업은 어렵지 않다.
        * 실제로 루트 도메인의 DNS 서버에 관한 정보는 DNS 서버 소프트웨어와 함께 설정 파일로 배포되어 있으므로 DNS 서버 소프트웨어를 설치하면 자동으로 등록이 완료된다.
    * 여기까지가 준비단계이다.
    * 이로써 DNS 서버는 수만대 이상 있는 DNS 서버 중에서 원하는 DNS 서버를 찾아낼 수 있다.
    * 과정 (브라우저가 gethostbyname을 호출하여 웹 서버의 주소를 조사하는 동안의 동작의 일부의 시작과 끝)
        * 클라이언트가 가장 가까운 DNS서버에게 www.naver.com을 요청한다.
        * 루트 도메인에게 해당 도메인이 있는지를 물어본다.
        * com 도메인의 DNS 서버에게 문의하라고 회신을 준다.
        * 가장 가까운 DNS 서버가 이번에는 루트 DNS서버에서 회신해준 com 도메인의 DNS서버로 www.naver.com을 요청한다.
        * naver.com 도메인의 DNS 서버 주소에게 물어보라고 회신해준다.
        * naver.com 도메인의 DNS 서버에게 www.naver.com을 요청한다.
        * naver.com 도메인의 DNS 서버에는 www.naver.com의 IP주소를 알고 있기 때문에 이 IP를 회신해준다.
        * 가장 가까운 DNS 서버는 IP를 회신받아 클라이언트에게 회신해준다.
        * 이로써 클라이언트는 웹 서버의 IP 주소를 알고 거기에 액세스 할 수 있게 된다.
    * DNS서버는 캐시 기능으로 빠르게 회답할 수 있다.
        
* 데이터 송, 수신 동작의 개요
    * IP 주소를 조사했으면 IP 주소의 상대, 여기에서는 액세스 대상 웹 서비스에 메시지를 송신하도록 OS 내부에 있는 프로토콜 스택에 의뢰한다.
    * 웹 서버에 보내는 HTTP의 메시지는 디지털 데이터이므로 디지털 데이터르 송신하도록 의뢰해야한다.
    * 또한 디지털 데이터를 송, 수신 하는 동작은 브라우저뿐만 아니라 네트워크를 이용하는 애플리케이션 전체에 공통이다.
    * 그러므로 이 동작은 웹에 한정되지 않고 모든 네트워크 애플리케이션에 해당된다.
    * 여기에서도 DNS 서버에 IP 주소를 조회할 떄와 같이 Socket 라이브러리에 들어있는 프로그램 부품을 이용한다.
    * IP 주소를 조회할 때처럼 프로그램 부품을 하나씩 호출하고 끝나지는 않는다.
    * 복수의 부품을 결정된 순번대로 호출해야 하므로 조금 복잡하다.
    * 데이터를 송, 수신하는 컴퓨터 사이에 데이터의 통로 같은 것이 있다.
    * 이것을 통해 데이터가 흐르면서 상대측에 도착한다.
    * 통로의 양 끝에 있는 데이터의 출입구를 소켓이라고 부른다.
    * 우선 이 소켓을 만들고 연결한다.
    * 실제로는 먼저 서버측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다린다.
    * 이렇게 해서 서버측이 기다리고 있는 동안에 클라이언트측에서 파이프를 연결한다.
    * 클라이언트 쪽에서 소켓을 맏늘고, 소켓에서 파이프를 늘려 서버측의 소켓에 연결하는 것이다.
    * 이로써 양쪽의 소켓이 연결되면 준비가 완료된 것이다.
    * 데이터를 전부 보내고 나면 연결했던 파이프가 분리된다.
    * 파이프를 연결할 떄는 클라이언트측에서 서버측을 향하여 연결했지만, 파이프를 분리할 때는 어느쪽에서 분리해도 상관없다.
    * 한쪽에서 분리하면 또 한쪽도 분리되고, 파이프를 분리하면 소켓을 말소하여 통신 동작이 종료된다.
    * 이 단계에 따라 Socket 라이브러리 안의 프로그램 부품을 호출하여 데이터의 송, 수신 동작을 실행한다.
    * 이 동작들을 실행하는 것은 OS 내부의 프로토콜 스택이다.
    * 브라우저 등의 애플리케이션은 자체에서 파이프를 연결하거나 거기에 데이터를 보낼 수 없다.
    * 프로토콜 스택에 의뢰해서 파이프를 연결하거나 데이터를 보낸다.
    * 의뢰 동작은 Socket 라이브러리에 넣은 프로그램 부품을 호출하여 실행되지만, 데이터 송, 수신용 프로그램 부품은 애플리케이션에서 의뢰받은 내용을 그대로 프로토콜 스택에 전달하는 중개역을 수행할 뿐 실질적인 작업은 하지 않는다.
    * 그렇기 때문에 프로그램 부품의 동작이 어떤 것인지를 알기 쉽게 보여줄 수 없다.

* 소켓의 작성 단계
    * 먼저 소켓을 만들어야 한다. (socket)
        * 소켓 라이브러리의 socket이라는 프로그램 부품만 호출하면 된다.
        * socket을 호출한 후의 동작은 socket 내부에 제어가 넘어가서 소켓을 만드는 동작을 실행한다.
        * 소켓이 생기면 디스크립터라는 것이 돌아온다.
        * 애플리케이션은 이것을 받아서 메모리에 기록해둔다.
            * 디스크립터       
                * 소켓을 식별하기 위해 사용하는 것이다.
                * 컴퓨터 내부에서는 복수의 데이터 송, 수신이 일어날 수 있기 때문에 식별이 필요하다.
                * 소켓일 만든 후 이것을 사용하여 접속 동작이나 데이터 송, 수신 동작을 실행하는데, 이때 디스크립터를 보여주면 프로토콜 스택이 어느 소켓을 사용하여 접속할지 또는 데이터를 송, 수신할지를 금방 판단할 수 있다.
    * 파이프를 연결하는 접속 단계 (connect)
        * connect를 호출하여 이 의뢰 동작을 실행한다.
        * connect를 실행할때는 디스크립터, 서버의 IP 주소, 포트 번호 3가지의 값이 필요하다.
            * 디스크립터
                * 디스크립터는 connect가 프로토콜 스택에 통지한다.
                * 그리고 프로토콜 스택이 통지받은 디스크립터를 보고 어느 소켓을 서버측의 소켓에 접속할지 판단하여 접속 동작을 실행한다.
            * IP주소
                * DNS서버에 조회하여 조사한 액세스 대상 서버의 IP 주소이다.
            * 포트 번호
                * IP주소로는 네트워크의 어느 컴퓨터인가 까지 알 수 있다.
                * IP주소로는 소켓까지 지정할 수 없다.
                * 그렇기 때문에 포트 번호가 필요하다.
                * IP주소와 포트번호를 이용해 어느 컴퓨터의 어느 소켓과 접속할지를 분명히 지정할 수 있다.
                * 서버측의 포트 번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다는 규칙이 있다.
                    * 웹은 80, 메일은 25번...
                * 서버 측에서도 클라이언트측의 포트 번호를 알아야 한다.
                    * 먼저 클라이언트측의 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라서 할당한다.
                    * 그리고 이 값을 프로토콜 스택이 접속 동작을 실행할 때 서버측에 통지한다.
        * connect를 호출하면, 프로토콜 스택이 접속 동작을 실행한다.
        * 그리고 상대와 연결되면 프로토콜 스택은 연결된 상대의 IP주소나 포트 번호등의 정보를 소켓에 기록한다.
        * 이로써 데이터 송, 수신이 가능한 상태가 된다.
        * 디스크립터
            * 애플리케이션이 소켓을 식별하는 것
        * IP와 포트
            * 클라이언트와 서버 간에 상대의 소켓을 식별하는 것

    * 메시지를 주고받는 송, 수신 단계 (write, read)
        * 소켓이 상대측과 연결되면 그 다음은 간단하다.
        * 소켓에서 데이터를 보내면 상대측의 소켓에 데이터가 도착한다.
        * 그러면 애플리케이션은 소켓을 직접 다룰 수 있으므로 Socket 라이브러리를 통해 프로토콜 스택에 그 일을 의뢰한다.
        * 그래서 write 라는 프로그램 부품을 사용한다.
            * 우선 애플리케이션은 송신 데이터를 메모리에 준비한다.
            * 사용자가 입력한 URL을 바탕으로 만든 HTTP 리퀘스트 메시지가 여기에서 말하는 송신 데이터이다.
            * 그리고 write를 호출할 때 디스크립터와 송신 데이터를 지정한다.
            * 그러면 프로토콜 스택이 송신 데이터를 서버에게 송신한다.
            * 소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명이 되어 그곳을 향해 데이터를 송신한다.
            * 이 송신 데이터는 네트워크를 통해 전부 그대로 액세스 대상의 서버에 도착한다.
            * 그러면 서버는 수신 동작을 실행하여 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메시지를 반송한다.
        * 이 메시지가 돌아오면 이번에는 메시지를 송신하는 동작이 필요하다.
        * 수신할 때는 Socket 라이브러리의 read를 사용하여 프로토콜 스택에 수신 동작을 의뢰한다.
        * 이떄 수신한 응답 메시지를 저장하기 위한 메모리 영역을 지정하는데, 이 메모리 영역을 수신 버퍼라고 부른다.
        * 그러면 응답 메시지가 돌아올 떄 read가 받아서 수신 버퍼에 저장한다.
        * 수신 버퍼는 애플리케이션 프로그램 내부에 마련된 메모리 영역이므로 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네준다.
    * 연결 끊기 단계에서 송, 수신이 종료된다. (close)
        * 브라우저가 데이터 수신을 완료하면 송, 수신 동작은 끝이난다.
        * 그 후 Socket 라이브러리의 close라는 프로그램 부품을 호출하여 연결 끊기 단계로 들어가도록 의뢰한다.
        * 그러면 소켓 사이를 연결한 파이프와 같은 것이 분리되고 소켓도 말소된다.
        * 웹에서 사용하는 HTTP프로토콜에서는 본래 응답 메시지의 송신을 완료했을 때 웹 서버측에서 연결 끊기 동작을 실행하므로 먼저 웹 서버측에서 close를 호출하여 연결을 끊는다.
        * 이것이 클라이언트측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다.
        * 그리고 브라우저가 read로 수신 동작을 의뢔했을 때 read는 수신한 데이터를 건네주는 대신 송, 수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에게 통지한다.
        * 이로써 송, 수신이 종료되었다는 것을 알 수 있으므로 브라우저에게서도 close를 호출하여 연결 끊기 단계에 들어간다.
    * 서버에서 복수의 데이터를 읽을 때 연결 끊기를 반복하는 것은 비효율적이므로 한 번 접속한 후 연결을 끊지 않고 복수의 리퀘스트와 응답 주고받기를 실행하는 방법이 마련되었다.
    * HTTP의 버전 1.1 에서 이 방법을 사용할 수도 있다.
    * 이 경우 리퀘스트해야 할 데이터가 없어진 상태에서 브라우저에게서 연결 끊기 동작에 들어갈 수 있다.
    * 메시지를 실제로 송, 수신 하는 것은 프로토콜 스택, LAN 드라이버, LAN 어댑터 3가지이다.

<!--  -->
* 프로토콜 스택과 LAN 어댑터
    * 프로토콜 스택
        * OS에 내장된 네트워크 제어용 소프트웨어
    * LAN 어댑터
        * 네트워크용 하드웨어
    * 프로토콜 스택과 LAN어댑터가 브라우저에서 받은 메시지를 서버에 전송한다.
* 프로토콜 스택의 내부 구성    
    * 애플리케이션
        * 네트워크 애플리케이션
            * 브라우저, 메일러(매일을 읽고 쓰는 소프트웨어), 웹 서버, 메일 서버 등의 프로그램
            * 여기서 부터 아래로 향하여 데이토 송, 수신 등의 일을 의뢰한다.
        * Socket 라이브러리
            * 애플리케이션의 아랫부분에 있다.
            * 그 안에는 리졸버가 내장되어 있다.
    * OS
        * TCP/UDP
            * 애플리케이션에서 보낸 의뢰를 받아 송, 수신 동작을 실행한다.
            * 브라우저나 메일 등의 일반적인 애플리케이션은 TCP를 사용한다.
            * DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송, 수신하는 경우에는 UDP를 사용한다.
        * IP
            * 패킷 송, 수신 동작을 제어한다.
            * 패킷을 통신 상대까지 운반하는 것이 IP의 주 역할이다
            * IP 안에는 ICMP와 ARP라는 프로토콜을 다루는 부분이 포함되어 있다.
                * ICMP
                    * 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지한다.
                * ARP
                    * IP주소에 대응하는 이더넷의 MAC 주소를 조사한다.
    * LAN 드라이버
        * LAN 어댑터의 하드웨어를 제어한다.
    * LAN 어댑터
        * 실제 송, 수신 동작을 한다.
        * 케이블에 대해 신호를 송, 수신 한다.
* 프로토콜 스택과 소켓
    * 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있다,
    * 여기에 통신 동작을 제어하기 위한 제어 정보를 기록한다.
        * 통신 상대의 IP 주소는 무엇인가.
        * 포트 번호는 몇 번인가.
        * 통신 동작이 어떤 진행 상태에 있는가.
    * 소켓은 개념적인 것이어서 실체가 없으므로 굳이 말하자면 이 제어 정보가 소켓의 실체라고 할 수 있다.
    * 또는 제어 정보를 기록한 메모리 영역이 소켓의 실체라고 말할 수 있다.
    * 프로토콜 스택은 이 제어정보를 참조하면서 동작한다.
    * 응답이 돌아오는지에 대한 여부가 기록된다
    * 송신 동작 후의 경과 시간 등이 기록된다.
    * 프로토콜 스택은 이 정보를 보고 포기 하거나 다시 보내는 동작을 실행한다.
    * 이 외에도 다양한 정보들을 기록하고 있다.
        * 윈도우의 경우 netstat이라는 명령이 있다.
        * 소켓의 내용을 화면에 표시할 수 있다.
        * 한 행이 하나의 소켓에 해당한다.
        * 소켓을 만든다는 것은 여기에 새로운 한 행의 제어 정보를 추가하고 '여기부터 통신을 시작하는 곳' 이라는 식으로 상태를 기록하거나 송, 수신 데이터를 일시적으로 저장하는 버퍼 메모리를 준비하는 등 통신을 준비하는 것이다.

* Socket을 호출했을 때의 동작 (socket -> connect -> write -> read -> close)
    * (socket) 소켓을 만드는 단계
        * socket을 호출하여 소켓을 만들 것을 의뢰한다.
        * 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만든다.
        * 이떄 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리 영역을 확보하는 것이다.
        * 만든 후, 초기 상태라는 것을 이 영역에 기록한다.
        * 소켓이 만들어지면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다.
        * 디스크립터는 프로토콜 스택의 내부에 있는 다수의 소켓중 어느 것을 가르키는지 나타내는 번호표와 같은 정보이다.
        * 디스크립터를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송, 수신 동작을 의뢰할 때 디스크립터를 통지한다.
        * 소켓에는 누가 누구와 통신하고 있는지, 그리고 그것이 어떤 상태로 있는지 등의 정보가 전부 기록되어 있으므로 디스크립터가 어느 소켓인지를 나타내면 필요한 정보는 전부 프로토콜 스택 쪽에서 알 수가 있다.
        * 이렇게 해서 통신 상대의 정보를 애플리케이션에서 일일이 통지받을 필요가 없다.
    * (connect) 접속하는 단계
        * 소켓을 만들면 브라우저는 connect를 호출한다.
        * 그러면 프로토콜 스택은 자기쪽의 소켓을 서버측 소켓에 접속한다.
        * 이더넷이나 통신 회선은 항상 케이블이 연결되어있다.
        * 따라서 언제나 신호를 보낼 수 있다.
        * 소켓을 만든 직후
            * 소켓을 만든 직후는 아직 거기에 아무 것도 기록되지 않으므로 통신 상대가 누구인지 모른다.
            * 이 상태에서는 송신 의뢰가 와도 데이터를 어디에 보낼지 알 수 없다.
            * 브라우저는 URL을 바탕으로 서버의 IP주소를 조사하고, 포트 번호를 80 번을 사용하도록 규칙으로 정해져 있어서 필요한 정보를 알 ㅅ ㅜ있다.
            * 그러나 브라우저가 알고 있는 정보만으로는 부족하다.
            * socket을 호출하여 소켓을 만드는 동작만으로는 프로토콜 스택에는 아무 것도 전달되지 않기 때문이다.
            * 그러므로 서버의 IP주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요하다.
            * 이것이 접속 동작의 한 가지 역할이다.
        * 서버 측
            * 서버측에도 소켓이 만들어졌지만 서버측의 프로토콜 스택도 클라이언트측과 마찬가지로 소켓을 만드는 동작만으로는 통신 상대를 알 수 없다.
            * 또한 서버측은 애플리케이션에서도 상대를 알 수 없다.
            * 그래서 클라이언트는 송신측 IP, PORT 번호와 데이터 송, 수신을 하고 싶다는 정보를 알려서 통신하려는 클라이언트가 있다는 것을 서버측에 전달한다.
            * 그러면 서버측의 프로토콜 스택도 클라이언트의 정보를 가질 수 있다.
        * 접속 동작의 첫 번째 동작은 통신 상대와의 사이에 제어 정보를 주고 받아 소켓에 필요한 정보를 기록하고 데이터 송, 수신이 가능한 상태로 만드는 것이다.
        * 여기에서 나온 클라이언트측의 IP주소나 포트 번호를 서버측에 알리는 것이 구체적인 예이다.
        * 제어 정보는 데이터 송, 수신 동작을 제어하기 위한 정보이다.
        * IP주소나 포트 번호는 대표적인 정보이다.
        * 그리고 접속 동작에서 주고 받는 제어 정보는 통신 규칙으로 정해져 있다.
        * 데이터 송, 수신 동작을 실행할 때는 송, 수신하는 데이터를 일시적으로 저장하는 메모리가 필요하다.
        * 이 메모리 영역을 '버퍼 메모리'라고 부른다.
        * 버퍼 메로리의 확보도 접속 동작을 할 때 실행된다.
        * 제어 정보에는 크게 두 종류가 있다.
            * 헤더에 기입되는 정보 / 소켓(프로토콜 스택의 메모리 영역) 에 기록되는 정보
            * 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보
                * TCP 헤더
                * 이것은 접속 동작 뿐만 아니라 데이터를 송, 수신하는 동작이나 연결을 끊는 동작을 포함하여 통신 동작 전체에서 어떤 정보가 필요한지를 검토하여 내용을 TCP 프로토콜의 사양으로 규정하고 있다.
                * 구체적으로 제어 정보가 규정되어 있다.
                * 접속, 송, 수신, 연결 끊기의 각 단계에서 클라이언트와 서버가 대화할 때마다 거기에 이 제어정보를 부가한다.
                * 즉, 패킷의 맨 앞 부분에 부가하는 것이다.
                * 접속 동작 단계에서는 아직 데이터의 송, 수신이 이루어지지 않으므로 패킷의 내용은 데이터는 없고 제어 정보만으로 이루어져 있다.
                * 이 제어 정보를 맨 앞부분에 배치하는 곳부터 헤더라고 부른다.
                * 헤더의 형태로 제어 정보를 주고 받는다.
                    * TCP 헤더의 포멧
                        * 16 송신처 포트 번호
                            * 이 패킷을 송신한 측의 프로그램의 포트 번호
                        * 16 수신처 포트 번호
                            * 이 패킷을 받는 상대 프로그램의 포트 번호
                        * 32 시퀀스 번호
                            * 이 패킷의 맨 앞 위치의 데이터가 송신 데이터의 몇 번째 바이트에 해당하는지를 송신측에서 수신측에 전달하기 위한 것이다.
                        * 32 ACK번호
                            * 데이터가 몇 바이트까지 수신측에 도착했는지를 수신측에서 송신측에 전달하기 위하 ㄴ것이다.
                            * 아크라고 읽는다.
                        * 4 데이터 오프셋
                            * 데이터 부분이 어디부터 시작하는지를 나타낸다.
                            * 헤더의 길이
                        * 6 사용하지 않음
                        * 6 컨트롤 비트
                            * 이 필드의 각 비트가 각가 통신 제어상의 의미를 가진다.
                                * URG
                                    * 긴급 포인터의 필드가 유효하다는 것을 나타낸다.
                                * ACK
                                    * 수신 데이터의 일련번호 필드가 유효하다는 것을 나타낸다.
                                * PSH
                                    * flush 동작에 의해 송신된 데이터임을 나타낸다.
                                * RST
                                    * 접속을 갖에로 종료하고 이상 종료시에 사용한다.
                                * SYN
                                    * 송신측과 수신측에서 일련번호를 서로 확인한다.
                                    * 이것으로 접속 동작을 나타낸다.
                                * FIN
                                    * 연결 끊기를 나타낸다.
                        * 16 윈도우
                            * 수신측에서 송신측에 윈도우 사이즈를 통지하기 위해 사용한다.
                                * 윈도우 사이즈
                                    * 수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터 양
                        * 16 체크섬
                            * 오류 유무를 검사하기 위한 것이다.
                        * 16 긴급 포인터
                            * 긴급하게 처리해야 할 데이타의 위치를 나타낸다.
                        * 옵션
                            * 위의 헤더 필드 이외의 제어 정보를 기록하기 위해 헤더에 옵션 필드를 추가할 수 있다.
                            * 그러나 접속 동작을 제외하면 옵션 필드를 사용하는 예는 적다.
            * 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보
                * 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 수시로 기록된다.
                * 송, 수신 동작의 진행 상황 등도 수시로 기록된다.
                * 프로토콜 스택은 하나하나 차례로 정보를 참조하면서 움직인다.
                * 소켓의 제어 정보는 프로토콜 스택의 프로그램과 일체화 되어 해도 좋을 것이다.
        * 소켓에 기록한 제어 정보는 상대측에서 볼 수 없다.
            * 왜냐하면 규칙에 따라 헤더에 제어 정보를 기록하여 대화하면, 그것으로 클라이언트와 서버가 서로 연락을 취하기 때문이다.
            * 예를 들어 내부 구조가 다른 윈도우와 리눅스는 프로토콜 스택을 만드는 방법이 다르다.
            * 필요한 제어 정보도 다르다.
            * 하지만 양자가 문제없이 통신할 수 있다.   
        * 접속 동작의 실제
            * connect(<디스크립터>, <서버측의 IP 주소와 포트 번호>, ...... )
            * 여기에 서버측 IP 주소와 포트 번호를 쓰면 명령이 프로토콜 스택의 TCP 담당 부분에 전달된다.
            * 그러면 TCP 담당 부분은 IP 주소로 표시된 상대, 즉 서버의 TCP 담당 부분과의 사이에 제어 정보를 주고 받는다.
            * 단계
                * 송신
                    * 데이터 송, 수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만든다.
                    * 송신처와 수신처의 포트 번호를 기록.
                    * 즉 접속해야 하는 소켓이 어느 것인지를 확실히 하고 컨트롤 비트인 SYN을 1로 만든다.
                    * 이렇게 해서 TCP 헤더를 만들면 이것을 IP 담당 부분에 건네주어 송신하도록 의뢰한다.
                    * 그러면 IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측 IP 담당 부분이 이것을 받아 TCP 담당 부분에 건네준다.
                    * 이후 서버측의 TCP 담당 부분이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아낸다.
                    * 접속을 기다리는 상태에 있는 소켓 중에서 TCP 헤더의 수신처 포트 번호와 같은 번호가 기록된 것이 해당하는 소켓이다.
                    * 해당하는 소켓이 발견되면 여기에 필요한 정보를 기록한다.
                    * 접속 동작이 진행중이라고 상태르 변경한다.
                    * 이 과정이 끝나면 TCP 담당 부분은 응답을 돌려 보낸다.
                * 회신
                    * 클라이언트와 마찬가지로 송신처와 수신처의 포트 번호나 SYN 비트 드을 설정한 TCP 헤더를 만든다.
                    * 그리고 응답을 돌려보낼 때 ACK 컨트롤 비트를 1로 만든다.
                    * 이것은 패킷을 받은 것을 알리기 위한 동작이다.
                    * 네트워크 오류가 있을수 있으므로 패킷이 없어지는 경우에는 패킷이 도착한 것을 확인하는 동작을 진행한다.
                    * 이것을 확인하기 위해 ACK 비트를 1로 만든다.
                        * 처음에 클라이언트가 서버로 패킷을 보낼 때는 그 앞에 패킷을 수신하지 않으므로 ACK를 0으로 만들어 보낸다.
                    * 그리고 TCP 헤더를 IP 담당 부분에 건네주어 클라이언트에 반송하도록 의뢰한다.
                    * 그러면 패킷이 클라이언트로 돌아온다.
                    * IP 담당 부분을 경유하여 TCP 담당 부분에 도착한다.
                    * 이때 TCP 헤더를 조사하여 서버측의 접속 동작이 성공 했는지를 확인한다.
                    * SYN이 1이면 접속 성공이므로 소켓 서버에 IP 주소나 포트 번호등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록한다.
                    * 마지막으로 클라이언트는 패킷이 도착한 것을 서버에게 알리기 위해 ACK 비트를 1로 만든 TCP 헤더를 반송한다.
                    * 그리고 이것이 서버에 도착하면 접속 동작의 대화가 끝난다.
            * 이로써 소켓은 데이터 송, 수신을 할 수 있는 상태가 된다.
            * 이때 파이프와 같은 것으로 소켓이 연결되었다고 생각할 수 있다.
            * 실제로 무언가로 연결되어 있지 않지만, 이렇게 생각하는 것이 네트워크 업계의 습관이다.
            * 이 파이프와 같은 것을 커넥션이라고 한다.
            * 또한 커넥션은 데이터 송, 수신 동작을 계속하고 있는 동안, 즉 close 호출하여 연결을 끊을 때 까지 계속 존재한다.
            * 이렇게 해서 커넥션이 이루어지면 프로토콜 스택 접속 동작이 끝나므로 connect의 실행이 긑나면서 애플리케이션을 제어할 수 있게 된다.
    * (write) 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘기기
        * connect에서 애플리케이션에 제어가 되돌아오면 데이터 송, 수신 동작에 들어간다.
        * 이 동작은 애플리케이션이 write를 호출하 송신 데이터를 프로토콜 스택에 건네주는 곳 부터 시작된다.
        * 이것을 받은 프로토콜 스택이 송신 동작을 실행한다.
        * 그러나 이 동작으로는 프로토콜 스택이 받은 데이터의 내용에 무엇이 쓰여있는지를 알지 못한다.
        * write를 호출할 때 송신 데이터의 길이를 지정하지만, 프로토콜 스택은 해당 길이만큼 바이너리 데이터가 1바이트씩 나열되어 있다고 인식할 뿐이다.
        * 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 일단 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다린다.
        * 데이터를 일단 저장하는 이유는
            * 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션의 종류나 만드는 방법에 따라 결정된다.
            * 데이터를 전부 요청하거나 1바이트씩 또는 1행씩 세분화하여 보낼 수도 있다.
            * 이 부븐은 프로토콜 스택에서 제어할 수 없다.
            * 이러한 상황에서 받은 데이터를 곧바로 보내는 단순한 방법이라면 작은 패킷을 많이 보낼 수 있다.
            * 그렇다면 네트워크의 이용 효율이 저하된다.
            * 따라서 어느 정도 데이터르 저장하고 나서 송, 수신 동작을 한다.
            * 어느 정도 까지만 저장한 후 송신 동작을 한다.
                * 판단의 요소는 한 패킷에 저장할 수 있는 데이터의 크기이다.
                    * 프로토콜 스택은 MTU라는 매개변수를 바탕으로 판단한다.
                        * MTU는 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이이다.
                        * 이더넷에서는 보통 1,500 바이트가 된다.
                        * 이 MTU에는 패킷의 맨 앞부분에 헤더가 포함되어 있다.
                        * 헤더(IP헤더, TCP헤더)를 제외한 것이 하나의 패킷으로 운반할 수 있는 데이터의 최대 길이이다.
                        * 이것을 MSS라고 한다.
                            * 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
                        * 애플리케이션에서 받은 데이터가 MSS를 초과하거나 MSS에 가까운 길이에 이르기까지 데이터를 저장하고 송신 도작을 하면 패킷이 잘게 나누어질 걱정을 할 필요가 없다.
                * 또 한가지 판단 요소는 타이밍이다.
                    * 애플리케이션의 송신 속도가 느려지는 경우 MSS에 가깝게 데이터를 저장하면 여기에서 시간이 걸려 송신 동작이 지연된다.
                    * 따라서 버퍼에 데이터가 모이지 않아도 적당한 곳에서 송신 동작을 실행해야 한다.
                    * 따라서 프로토콜 스택은 내부에 타이머가 있다.
                    * 이것으로 일정 시간 이상 경과하면 패킷을 송신한다.
                * 판단 요소는 두 가지이지만 이 둘은 상반된 면도 있다.
                * 전자를 중시하면 패킷의 길이가 길어져서 네트워크의 이용 효율이 높아지지만 버퍼에 머무는 시간만큼 송신이 지연된다.
                * 그러나 TCP 프로토콜의 사야에는 절충에 관한 규정은 없다.
                * 실제로 어떻게 판단해야 할지는 프로토콜 스택을 만드는 개발자에게 맡겨져 있다.
                * 이렇듯 프로토콜 스택에만 맡긴다면 좋지 않은 일이 생길수도 있다.
                * 그래서 애플리케이션측에서 송신의 타이밍을 제어하는 여지도 남겨두었다.
                * 이럴 때 송신을 의뢰할 때 옵션을 지정하면 된다.
                    * ex) 버퍼에 머물지 않고 바로 송신할 것,
        * 데이터가 클 때는 분할하여 보낸다.
            * HTTP 리퀘스트 메시지는 보통 그다지 길지 않아 한개의 패킷에 들어간다.
            * 그러나 폼을 사용하여 보낼 경우 등 한 개의 패킷에 들어가지 않을 만큼 긴 것도 있다.
                * ex) 블로그나 게시판등에서 긴 문장을 투고할 경우
            * 이 경우 송신 버퍼에 저장된 데이터는 MSS의 길이를 초과한다.
            * 다음 데이터를 기다릴 필요가 없다.
            * 따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신한다.
        * ACK 번호를 사용하여 패킷이 도착했는지 확인한다.
            * 데이터를 입력한 패킷이 서버로 송신되는데, 데이터 송신 동작은 이것으로 끝나지 않는다.
            * TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지를 확인하고, 도착하지 않았으면 다시 송신하는 기능이 있다.
            * 따라서 패킷을 송신한 후에는 확인 동작으로 넘어간다.
                * TCP 담당 부분은 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번쨰 바이트에 해당하는지를 세어둔다.
                * 그리고 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록한다.
                    * 이 부분이 시퀀스 번호 항목이다.
                * 그리고 송신하는 데이터의 크기도 수신측에 전달하지만 여기에서는 헤더에 기록하여 수신측에 알리지 않는다.
                * 패킷 전체의 길이에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있으므로 수신측에서 이 방법에 따라 크기를 산출한다.
                * 이들 두 가지 방법으로 송신한 데이터가 몇 번째 바이트부터 시작되는 몇 바이트 분의 것인지 알 수 있다.
                * 이렇게 하면 수신측에서 패킷이 누락되었는지 확인할 수 있다.
                    * ex) 1,460번째 바이트까지 수신 완료한 상태에서 시퀀스 번호가 1461인 패킷의 여부에 따라 누락의 여부를 확인할 수 있다.
                * 이렇게 해서 누락이 없는 것을 확인하면 수신측은 그 이전에 수신한 데이터와 합쳐서 데이터를 몇 번째 바이트까지 수신한 것인지 계산한다.
                * 그 값을 TCP 헤더의 ACK 번호에 기록하여 송신측에 알려준다.
                * 이 ACK 번호를 되돌려주는 동작을 수신 확인 응답이라고 부른다.
                * 송신측은 이것을 통해 상대가 어디까지 수신했는지를 파악한다.
            * 실제로 시퀀스 번호는 1이 아닌 난수를 바탕으로 산출된 초기값으로 시작된다.
            * 시작이 1로 예측되면, 악의적인 공격을 할 우려가 있기 때문이다.
            * 그러나 난수로 결정하면 몇 번이 초기값인지 알 수가 없다는 문제가 생긴다.
            * 데이터의 송, 수신을 시작하기 전에 초기값을 상대에게 알려주어야 한다.
            * SYN 제어비트를 1로 하여 서버에 보내는 과정이 있는데, 이 과정이 초기값을 통지하는 것을 나타낸다.
            * SYN을 1로 하여 서버에 보낼 때 시퀀스 번호에도 값을 설정하게 되어있어서 그 번호의 값이 초기값을 나타낸다.
            * 그러나 이것만으로 충분하지 않은 경우가 있다.
            * 왜냐하면 이 설명은 데이터의 흐름을 한 개만 고려하고 있기 때문이다.
            * 위의 과정을 서버와 클라이언트 서로가 작동하면 된다.
        * 동작
            * 클라이언트
                * 먼저 접속 동작을 실행할 클라이언트에서 서버로 보내는 데이터에 관한 시퀀스 번호의 초기값을 클라이언트에서 산출하여 서버에 통지한다.
            * 서버
                * 그러면 서버에서 초기값으로부터 ACK 번호를 산출하여 클라이언트에 반송한다.
                * 최초의 초기값 통지가 도중에 없어질 수 있으므로 이것이 서버에 도착한 것을 알리기 위해 ACK 번호를 반송한다.
                * 이때 서버에서 클라이언트에 보내는 데이터에 관한 시퀀스 번호의 초기값을 서버에서 산출하여 이 값도 함께 클라이언트에 통지한다.
            * 클라이언트
                * 그러면 클라이언트에서도 서버와 마찬가지로 받은 시퀀스 번호의 초기값으로부터 ACK 번호를 산출하여 서버에 반송한다.
                * 이로써 시퀀스 번호와 ACK 번호가 준비되었으므로 데이터 송, 수신 동작에 들어간다.
            * 데이터 송, 수신 동작은 본래 양방향으로 데이터를 보낼수 있지만, 웹의 경우는 최초 클라이언트에서 서버로 메시지를 보낼 것이고, 데이터와 함께 시퀀스 번호를 보낸다.
            * 그러면 데이터를 수신한 서버에서 ACK 번호를 반송한다.
            * 서버에서 클라이언트에 데이터를 보내는 경우에는 그 반대가 된다.
            * TCP는 이 방법으로 상대가 데이터를 받은 것을 확인하는데, 확인할 떄까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관해둔다.
            * 그리고 송신한 데이터에 대응하는 ACK 번호가 상대로부터 돌아오는지를 확인한다.
            * 돌아오지 않으면 패킷을 다시 보낸다.
            * 이 구조는 매우 강력하다.
            * 오류를 검출하여 회복 처리를 취할 수 있다.
            * 이 때문에 LAN 어댑터, 버퍼, 라우터 모두 회복 조치를 취하지 않아도 된다.
            * 오류를 검출하면 그 패킷을 버리기만 하면 된다.
            * 애플리케이션도 마찬가지이다.
            * TCP에 맡겨두면 오류가 발생해도 데이터가 문제 없이 상대에게 도착하므로 애플리케이션의 송신 동작은 송신한 채로 끝난다.
            * 단 도중에 케이블이 분리되거나 서버가 다운되는 등의 이유로 TCP가 아무리 다시 보내도 데이터가 도착하지 않는 경우도 있다.
            * 이때 한없이 다시 보내면 곤란하므로 TCP는 몇 번 다시 보낸 후 회복의 전망이 없는 것으로 보고 데이터 송신 동작을 강제로 종료하고 애플리케이션 오류를 통지한다.
        * 대기시간 조정
            * 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정
                * 이것이 기본이지만 실제 오류 겁출과 회복의 원리는 꽤 복잡하다.
                * 먼저 ACK 번호가 돌이오는 것을 기다리는 시간인데, 이 대기 시간을 타임아웃 값이라고 한다.
                    * 네트워크가 혼잡하여 정체가 일어나면 ACK 번호가 돌아오는 것이 지연될 수 있다.
                    * 대기시간이 너무 짧지도, 길지도 않아야 한다.
                    * 하지만 이것은 매우 어렵다.
                    * 그래서 TCP는 대기 시간을 동적으로 변경하는 방법을 취한다.
                    * ACK가 돌아오는 시간을 기준으로 대기 시간을 판단하는 것이다.
                    * 구체적으로는 데이터 송신 동작을 실행하고 있을 떄 항상 ACK 번호가 돌아오는 시간을 계측해둔다.
                    * 그리고 ACK 번호가 돌아오는 시간이 지연되면 이것에 대응하여 대기 시간도 늘린다.
            * 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리
                * 윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법이다.
                * 그러면 ACK 번호가 돌아올 때까지의 시간이 낭비되지 않는다.
                * 그러나 수신측의 능력을 초과하여 패킷을 보내는 일이 생길수도 있다.
                    * 수신측의 TCP는 패킷을 수신하면 일단 수신용 버퍼 메모리에 데이터를 일시 보관한다.
                    * 수신측에서는 ACK 번호를 계산하거나 조각을 연결하여 원래 데이터를 복원한 후 애플리케이션에 건네주어야 한다.
                    * 따라서 처리가 끝나지 않는 상태에서 다음 패킷이 도착해도 곤란하지 않도록 수신 버퍼를 설치하고, 여기에 수신된 데이터를 일시 보관하는 것이다.
                    * 애플리케이션에서 건네주는 속도보다 빠른 속도로 데이터가 도착하면 수신 버퍼가 넘쳐버린다.
                    * 넘친 데이터는 없어져 버리므로 패킷이 도착해도 오류가 발생한 것처럼 된다.
                    * 이 사태는 다음과 같은 방법으로 피할 수 있다.
                        * 먼저 수신측에서 송신측에 수신 가능한 데이터 양을 통지한다.
                        * 수신측은 이 양이 초과하지 않도록 송신 동작을 실행한다.
                        * TCP 헤더의 윈도우 필드에서 이것을 송신측에 알린다.
            * ACK 번호와 윈도우를 합승한다.
                * 윈도우 통지의 타이밍
                    * 수신 데이터가 수신 버퍼에 보관되면 윈도우를 하나하나 차례대로 수신측에 통지할 필요가 없다.
                    * 윈도우의 값은 송신측이 데이터를 송신할 때마다 송신한 데이터만큼 감산하여 스스로 산출할 수 있다.
                    * 윈도우 통지가 필요한 것은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 떄이다.
                    * 이 동작은 수신측의 애플리케이션에서 보낸 의뢰가 계기가 되어 일어나므로 언제 일어날지 송신측에서는 알 수 없다.
                    * 그러므로 수신측에서 애플리케이션에 데이터를 건네주고 수신 버퍼의 빈 영역이 늘어났을 떄 이것을 송신측에 통지해야 하는데, 이것이 윈도우 통지의 타이밍이다.
                * ACK
                    * ACK는 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보낸다.
                    * 즉 데이터를 수신한 후 즉시 보낸다.
                * 이 두가지를 조합해보면 먼저 송신측에서 보낸 데이터가 수신측에 도착하여 수신 동작이 정상적으로 완료되었을 때 ACK 번호를 송신측에 통지하고, 잠시 후 데이터를 애플리케이션에 건네주었을 떄 윈도우를 송신측에 통지하는 상태가 된다.
                * 본래의 개념을 그대로 실현하면 데이터의 패킷을 수신할 때 마다 ACK 통지와 윈도우 통지의 패킷이 하나씩 따로 송신측에 보내진다.
                * 이러면 효율이 저하된다.
                * 수신측은 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다린다.
                * 이렇게 기다리는 사이에 다음 통지 동작이 일어나면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 보낸다.
                    * ex) ACK 번호의 송신을 대조할 때 윈도우 통지가 일어나면 ACK 번호와 윈도우를 한 개의 패킷에 합승시켜서 통지하여 패킷의 수를 줄일 수 있다.
                * 복수의 ACK 번호 통지가 연속해서 일어난 경우에도 패킷의 수를 줄일 수 있다.
                * ACK 번호는 데이터를 어디까지 받았는지, 즉 수신한 데이터의 끝이 어디인지를 송신측에 알리는 것이므로 ACK 번호 통지가 연속하여 일어나면 최후의 것만 통지하고 도중의 것은 생략해도 된다.
                * 이렇게 하면 패킷을 줄일 수 있고, 윈도우 통지가 연속된 경우에도 마찬가지로 줄일 수 있다.
    * (read) HTTP 응답 메시지를 수신한다.
        * HTTP 리퀘스트 메시지를 보내면 다음에는 웹 서버에서 응답 메시지가 돌아오기를 기다린다.
        * 응답 메시지가 돌아오면 그것을 수신한다.
        * 수신하기 위해 read 프로그램을 호출한다.
            * read 를 경유하여 프로토콜 스택에 제어가 넘어간다.
            * 데이터를 수신할 때도 데이터를 송신할 때와 마찬가지로 데이터를 일시 보관하는 수신 버퍼를 사용한다.
            * 먼저 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네준다.
            * 이떄 리퀘스트 메시지의 송신을 완료하고 나서 얼마 안 된 시점이라면 아직 응답 메시지가 돌아오지 않았을 것이다.
            * 응답 메시지가 돌아올 때까지 다소 시간이 걸리므로 수신 버퍼에 데이터가 들어가지 않았을 것이다.
            * 이 상태에서는 더 이상 작업을 먼저 진행할 수 없다.
            * 그래서 프로토콜 스택은 의뢰받은 작업, 즉 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네주는 작업을 잠시 보류한다.
            * 그리고 서버에서 응답 메시지의 패킷이 도착했을 때 그것을 수신하여 애플리케이션에 건네주는 작업을 재개한다.
        * 동작
            * 수신한 데이터 조각과 TCP 헤더의 내용을 조사한다.
            * 도중에 데이터가 누락되었는지 검사한다.
            * 문제가 없으면 ACK 번호를 반송한다.
            * 그리고 데이터 조각을 수신 버퍼에 일시 보관한다.
            * 조각을 연결하여 데이터를 원래 모습으로 복원한 후 애플리케이션에 건네준다.
                * 구체적으로는 수신 데이터를 애플리케이션이 지정한 메모리 영역에 옮겨 기록 후 애플리케이션에 제어를 되돌려준다.
            * 애플리케이션에 데이터를 건네주고 나서 타이밍을 가늠하여 윈도우를 송신측에 통지한다.
    * (close) 데이터를 보내기를 완료했을 때 연결을 끊는다.
        * 종료를 하는 시점은 애플리케이션이 송신을 완료했다고 판단했을 때이다.
            * ex) 웹 브라우저가 서버에 데이터를 요청한다.
            * 브라우저가 웹 서버에 리퀘스트 메시지를 만들어 보낸다.
            * 서버가 이것에 응답하여 응답 메시지를 반송한다.
            * 데이터 보내기가 완료되었다.
            * 이 경우 서버측에서 연결 끊기 단계에 들어간다.
        * 과정
            * 서버
                * (위의 예시에선)서버측 애플리케이션이 먼저 close를 호출한다.
                * 그러면 서버측의 프로토콜 스택이 TCP 헤더를 만든다.
                * 여기에 연결 끊기를 나타내는 정보를 설정한다.
                    * 컨트롤 비트의 FIN 비트에 1을 설정한다.
                * IP 담당 부분에 의뢰하여 클라이언트에 송신을 의뢰한다.
                * 이와 동시에 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록한다.
            * 클라이언트
                * 서버에서 FIN에 1을 설정한 TCP 헤더가 도착하면 클라이언트 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기에 들어갔다는 것을 기록한다.
                * 그리고 FIN을 1로 설정한 패킷을 받은 사실을 알리기 위해 ACK 번호를 서버측에 반송한다.
                * 이것이 끝나면 애플리케이션이 데이터를 가지러 올 때까지 기다린다.
                * 잠시 후 애플리케이션이 read를 호출하여 데이터를 가지러 올 것이다.
                * 그러고 나면 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 클라이언트측 애플리케이션에 알린다.
                * 웹의 동작은 서버가 응답을 반송하면 끝나도록 규칙이 정해져 있으므로 서버에서 보낸 데이터를 전부 수신 완료하면 클라이언트도 종료한다.
                * 그래서 클라이언트측의 애플리케이션도 close 를 호출하여 데이터 송, 수신 동작을 끝낸다.
                * 그러면 클라이언트측의 프로토콜 스택은 서버측과 마찬가지로 FIN 비트에 1을 설정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 서버로 송신한다.
            * 서버
                * 서버에서 ACK 번호가 돌아오면 서버와의 대화가 끝난다.
        * 소켓을 말소하다.
            * 서버와의 대화가 끝나면 소켓을 사용하여 서버와 대화할 수 없게 된다.
            * 이때 소켓은 필요 없지만, 거기서 바로 소켓을 말소하지 않고 잠시 기다린 다음 소켓을 말소한다.
            * 오동작을 막기 위해 잠시 기다린다지만, 오동작이 일어나는 이유는 다양하다.
    * 정리
        * 접속
            * 서버
                * 데이터 송, 수신에서 최초의 동작은 소켓을 작성하는 단계이다.
                * 보통은 먼저 서버측에서 애플리케이션이 동작하기 시작했을 때 소켓을 만들고 이것을 접속 대기 상태로 만든다.
                * 소켓을 만들면 클라이언트에서 서버를 향해 접속 동작을 실행한다.
            * 클라이언트
                * 먼저 클라이언트가 SYN을 1로 만든 TCP 헤더를 만들어 서버에 보낸다.
                * 이 TCP 헤더에는 클라이언트가 서버에 데이터를 보낼 떄 사용하는 시퀀스 번호의 초기값도 기록되어 있다.
                * 또한 서버에서 클라이언트에 데이터를 송신할 때 이용하는 윈도우의 값도 기록되어 있다.
            * 서버
                * 이것이 서버에 도착하면 서버에서 SYN을 1로 만든 TCP 헤더가 돌아온다.
                * 이 TCP 헤더에도 시퀀스 번호, 윈도우 번호가 기록되어 있다.
                * 그리고 클라이언트로 부터 메시지를 받은 것을 나타내는 ACK 번호도 기록되어 있다.
            * 클라이언트
                * 이것이 클라이언트에 도착하면 TCP 헤더를 받은 것을 나타내는 ACK 번호를 기록한 TCP 헤더를 클라이언트가 서버에 보낸다.
                * 이것으로 접속 동작은 끝나고 송, 수신 단계에 들어간다.
        * 송, 수신
            * 클라이언트
                * 웹의 경우 클라이언트에서 서버에 리퀘스트 메시지를 보내는 것부터 시작한다.
                * TCP는 이것을 적당한 크기의 조각으로 분할한다.
                * 그 후 TCP 헤더를 맨 앞에 부가하여 서버에 보낸다.
                * TCP 헤더에 송신 데이터가 몇 번쨰 바이트부터 시작되는지를 나타내는 시퀀스 번호가 기록 되어 있을것이다.
            * 서버
                * 이것이 서버에 도착하면 서버는 ACK 번호를 클라이언트에 반송한다.
                * 최초의 데이터 조각인 경우 서버는 데이터를 받기만 하지만, 데이터 송, 수신이 진행되면 애플리케이션에 데이터를 건네주어 수신 버퍼에 빈 영역이 생기는 장면이 나오는데, 이때 윈도우의 값도 기록하여 클라이언트에 통지한다.
                * 이렇게 해서 클라이언트에서 서버에 리퀘스트 메시지를 보내면 서버가 응답 메시지를 반송한다.
        * 종료
            * 서버가 응답 메시지 보내기를 완료하면 데이터 송, 수신 동작이 끝난다.
            * 이 때 서버가 연결 끊기 동작에 들어간다.
            * 먼저 서버는 FIN을 1로 만든 TCP 헤더를 클라이언트로 보낸다.
            * 클라이언트는 이것을 받았음을 나타내는 ACK 번호를 보낸다.
            * 이후 클라이언트는 애플리케이션이 read작업으로 종료를 확인할 것이다.
            * 클라이언트는 FIN을 1로 만든 TCP 헤더를 서버로 보낸다.
            * 서버는 ACK 번호와 TCP 헤더를 보낸다.
            * 잠시 후에 소켓이 말소된다.

* 패킷의 구성
    * 데이터를 저장한 패킷
        * 이더넷이나 IP의 헤더 / TCP 헤더 / 데이터 조각(애플리케이션의 데이터를 조각으로 나눈 것)
    * 제어 정보만 있는 패킷
        * 이더넷이나 IP의 헤더 / TCP 헤더
