* URL의 맨 앞 
    * 브라우저는 웹 서버에 액세스하는 클라이언트로 사용하는 경우가 많다.
    * http
    * 하지만, 다른 기능도 많다.
    * ftp->파일 다운/업로드
    * mailto->메일의 클라이언트 기능
    * URL의 맨 앞에 있는 문자열에서 액세스하는 방법을 나타낸다
    * 액세스 대상이 웹 서버라면 http, ...
    * file: -> 클라이언트 PC 자체의 파일에서 데이터를 읽어온다 
    * 이와 같이 반드시 프로토콜을 나타낸다고 할 수는 없다.
    * URL의 맨 앞은 액세스 방법!!


* 브라우저는 먼저 URL을 해독한다.
    * 리퀘스트의 메시지를 작성하기 위해 URL을 해독한다.
    * http: + // + 웹 서버 명 + ( / + 디렉토리명 + / 파일명 ) 생략 가능
    * http: 데이터에 액세스 하는 방법.
    * //는 나중에 이어지는 문자열이 서버의 이름임을 나타냄
    * .com 뒤에 디렉토리가 생략 될 수 있다.
        * 이 경우 대부분의 서버가 index.html이라는 파일 명을 설정해 둔다.
    
* http의 기본 개념
    * http 프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이다.
    * 클라이언트가 서버를 향해 메세지를 보낸다.
    * 메세지 안에는 '무엇을', '어떻게 해서' 하겠다는 내용이 쓰여있다.
        * '무엇을'에 해당하는 것을 URI라고 한다.
            * 보통 페이지 데이터를 저장한 파일의 이름이나 CGI 프로그램의 파일 명을 URI로 쓴다.
            * ex) /dir1/file1.html, /dir1/program1.cgi
            * 그러나 URI는 그것만이 아니라 여기에 http:로 시작하는 URL을 그대로 쓸 수도 있다.
            * 즉 여기에는 다양한 액세스 대상을 쓸 수 있다.
            * 이러한 액세스 대상을 통칭하는 말이 URI이다.
        * '어떻게 해서'에 해당하는 것은 메소드이다.
            * 메소드에 의해 웹 서버에 어떤 동작을 하고 싶은지를 전달한다.
                * ex) URI로 나타낸 데이터를 읽고 싶다, 클라이언트측에서 입력한 데이터를 URI로 나타낸 프로그램에 전달하고 싶다.
                * ex) GET, POST, ...
        * 보충 정보를 나타내는 헤더 파일도 있다.
            * 클라이언트에서 웹 서버에 데이터를 전송할 경우에는 헤더 필드의 뒤에 데이터가 들어간다.
    * 리퀘스트 메시지가 웹 서버에 도착하면 웹 서버는 그 속에 쓰여있는 내용을 해독한다.
    * 그리고 URI와 메시지를 조사하여 '무엇을', '어떻게 하는지' 를 판단 후 요구에 따라 동작한다.
    * 결과 데이터를 응답 메세지에 저장한다.
        * 응답 메세지의 맨 앞부분에는 실행 결과가 정상 종료되었는지, 이상이 발생했는지를 나타내는 스테이터스 코드가 있다.
            * ex) 404 not found,...
        * 그 후 헤더 파일과 페이지의 데이터가 이어진다.
    * 응답 마세지를 클라이언트에 반송한다.
    * 이것이 클라이언트에 도착하여 브라우저가 메시지 안에서 데이터를 추출하여 화면에 표시하면서 HTTP의 동작은 끝난다.

* 메소드
    * GET
        * 웹 서버에 액세스 하여 페이지의 데이터를 읽을 떄 사용한다.
        * 리퀘스트 메시지의 메소드에 'GET'이라고 쓰고, URI에는 '/dir1/file1.html' 과 같이 페이지의 데이터를 저장한 파일의 이름을 쓴다.
        * 이렇게 해서 해당 파일을 읽으라는 의미가 완성된다.
        * 이 메시지가 웹 서버에 도착하면 서버는 해당 파일을 열고 내용의 데이터를 추출한다.
        * 그리고 추출한 데이터를 응답 메세지에 포함해서 클라이언트에게 반송한다.
    * POST
        * 폼에 데이터를 사용해서 웹 서버에 송신하는 경우에 사용된다.
        * URI에는 웹 서버 기계에서 동작하는 애플리케이션 프로그램의 파일명을 쓴다.
        * 'index.cgi'나 'index.php'라는 파일명이 대표적이다.
        * 그리고 리퀘스트 메시지 안에는 메시지와 URI와 더불어 CGI 프로그램이나 스크립트에 건네주는 데이터를 넣는다.
        * 이 데이터는 사용자가 필드에 입력한 값이다.
        * 메시지가 서버 기계에 도착하면 웹 서버 소프트웨어는 URI에 지정된 애플리케이션 프로그램에게 리퀘스트 메시지의 안에 있는 데이터를 건네준다.
        * 그리고 이 프로그램이 출력하는 데이터를 받아서 응답 메시지에 포함시킨 후 클라이언트에게 반송한다.
    * 이 두가지가 HTTP의 대표적인 사용법이다.
    * 인터넷에서 이것들 이외에 메소드를 사용하는 예는 거의 없다.

* HTTP Request message
    * URL을 해독하고 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP Request message를 만든다.
    * 실제 HTTP 메시지를 쓰는 방법, 즉 포맷이 결정되어 있으므로 브라우저는 이 포맷에 맞게 리퀘스트 메시지를 만든다.
    * 첫 번째 행 (리퀘스트 라인)
        * 첫 번째 행에 있는 리퀘스트 라인을 쓴다.
        * 이 행에서 중요한 것은 맨 앞에 있는 메소드이다.
        * 이것을 통해 웹 브라우저는 웹 서버에 어떻게 할 것인지를 전달한다.
        * 메소드를 썼으면 한 칸 띄운 다음에 URI를 쓴다.
        * URI 부분에는 보통 /<디렉토리명>/.../<파일명> 을 쓰는 것이 일반적이다.
        * URL에서 경로를 추출하여 복사한다.
        * 그리고 첫 번째 행의 끝에 메시지가 http의 어느 버전의 사양을 바탕으로 쓴 것인지를 나타내기 위해 버전 번호를 써서 첫 번째 행을 완료한다.
    * 두 번째 행 이후 (메시지 헤더)
        * 메시지 헤더라는 행이 이어진다.
        * 첫 번째 행에서 리퀘스트의 내용을 대략 알 수 있지만, 부가적인 자세한 정보가 필요한 경우도 있다.
        * 이것을 써 두는 것이 메시지 헤더의 역할이다.
        * 날짜, 클라이언트측이 취급하는 데이터의 종류, 언어, 압축형식, 클라이언트나 서버의 소프트웨어 명칭과 버전, 데이터의 유효 기간이나 최종 변경 일시 등 다수의 항목이 사양으로 정해져 있다.
        * 메세지 헤더에 쓰는 내용은 브라우저의 종류나 버전, 설정등에 따라 달라진다.
        * 몇 행에서 열 줄 이상의 메시지 헤더를 쓰는 경우가 많다.
    * 그 다음 (메시지 본문)
        * 메시지 헤더르 쓰면 그 뒤에 아무 것도 쓰지 않은 하나의 공백 행을 넣고, 그 뒤에 송신할 데이터를 쓴다.
        * 이 부분을 메시지 본문 이라고 한다.
        * 메시지의 실제 내용이다.
        * 단 메소드가 GET인 경우에는 메소드와 uri만으로 웹 서버가 무엇을 할지 판단할 수 있으므로 메시지 본문에 쓰는 송신 데이터는 아무 것도 없다.
        * 따라서 메시지 헤더가 끝난 곳에서 메시지는 끝난다.
        * 메시지가 post 인 경우에는 폼에 입력한 데이터등을 메시지 본문 부분에 쓴다.
        * 이로써 리퀘스트 메시지 작성 동작이 완료된다.

* 리퀘스트 메시지를 보내면 응답이 돌아온다.
    * 이 메시지를 보내면 웹 서버에서 응답 메시지가 돌아온다.
    * 응답 메시지의 포맷도 기본적인 개념은 리퀘스트 메시지와 같다.
    * <b>그러나 첫 번째 행이 다르다.</b>
    * 응답의 경우는 정상 종료 했는지, 오류가 발생했는지, 즉 리퀘스트의 실행 결과를 나타내는 스테이터스 코드와 응답 문구를 첫 번째 행에 써야 한다.
    * 이들 둘은 내용이 같지만 용도가 다르다.
    * 스테이터스 코드
        * 숫자로 쓴 것이다.
        * 주로 프로그램 등에 실행 결과를 알려주는 것이 목적이다,
            * 1xx
                * 처리의 경과 상황 등을 통지한다.
            * 2xx
                * 정상 종료
            * 3xx
                * 무언가 다른 조치가 필요함을 나타낸다.
            * 4xx
                * 클라이언트측의 오류
            * 5xx
                * 서버측의 오류
    * 응답 문구
        * 문장으로 쓰여있다.
        * 사람에게 실행 결과를 알리는 것이 목적이다.
    * 응답 메세지가 돌아오면, 그때부터 데이터를 추출한 후 화면에 표시하면 웹 페이지를 눈으로 볼 수 있다.
    * 페이지가 문장으로만 되어있으면 이것으로 끝이다.
    * 영상 등이 포함되어 있는 경우에는 계속 내용이 남아 있는다.
        * 영상 등을 포함한 경우에는 문장 안에 영상 파일을 나타내는 태그 라는 제어 정보가 포함되어 있다.
        * 브라우저는 화면에 문장을 표시할 때 태그를 탐색한다.
        * 그리고 영상을 포함하고 있는 의미의 태그를 만나면 그곳에 영상용 공백을 비워두고 문장을 표시한다.
        * 이후 다시 한 번 웹 서버에 액세스 하여 태그에 쓰여있는 영상 파일을 웹 서버에서 읽어와서 방금 전에 비워둔 공백에 표시한다.
        * 이 경우 문장 파일을 읽을 때와 마찬가지로 URI 부분에 영상 파일의 이름을 쓴 리퀘스트 메시지를 만들어 보낸다.
    * 리퀘스트 메시지에 쓰는 URI는 한 개만으로 결정되어 있으므로 파일을 한 번에 한 개씩만 읽을 수 있기 때문에 파일을 따로따로 읽어야 한다.
        * 예를 들면 한 문장에 3개의 영상이 포함되어 있다면, 문장 파일을 읽는 리퀘스트와 영상 파일을 읽는 리퀘스트로, 총 4회 리퀘스트 메시지를 웹 서버에 보낸다.
    * 이렇게 해서 필요한 파일을 판단하고 이것을 읽은 후 레이아웃을 정하여 화면에 표시하는 상태로 전체의 동작을 조정하는 것도 브라우저의 역할이다.
    * 웹서버는 이러한 사정을 모른다.
    * 4회의 리퀘스트가 한 개의 페이지인지, 아니면 별도의 페이지 인지 전혀 신경쓰지 않는다.
    * 단순히 한개의 리퀘스트에 대해 한 개의 응답만 돌려보낼 뿐이다.
    
* IP주소의 용도
    * HTTP의 메세지를 만들면 다음에는 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에 송신한다.
    * 브라우저는 URL을 해독하거나 HTTP 메시지를 만든다.
    * 그러나, 메시지를 네트워크에 송출하는 기능은 없다.
    * 그래서 OS에 의뢰한다.
    * 이떄 URL 안에 쓰여있는 서버의 도메인명에서 IP주소를 조사해야 한다.
    * OS에 송신을 의뢰할 때는 도메인명이 아니라 IP주소로 메시지를 받을 상대를 지정해야 하기 때문이다.

* TCP/IP
    * 인터넷이나 사내 LAN은 TCP/IP의 개념에 기초하여 만들어졌다.
    * TCP/IP는 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어 진다고 생각할 수 있다.
    * 서브넷이란, 허브에 몇 대의 PC가 접속된 것이라고 생각해도 좋다.
    * 이것을 한 개의 단위로 생각하여 서브넷이라고 부른다.
    * 라우터에서 연결하면 네트워크 전체가 완성된다.
    * 서브넷에 네트워크 번호를 할당한다.
    * 컴퓨터에 호스트 번호를 할당한다.
    * 이 두 주소를 합쳐서 IP 주소라고 한다.

* 메시지 운반 과정
    * 액세스 대상의 서버까지 메시지를 운반할 때는 이 IP주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반한다.
    * 송신측이 메시지를 보내면 서브넷 안에 있는 허브가 운반한다.
    * 송신측에서 가장 가까운 라우터까지 도착한다.
    * 그리고 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단한다.
    * 그리고 거기에 보내도록 지시한다.
    * 그 다음 다사 서브넷의 허브가 라우터까지 메시지를 보낸다.
    * 이런 동작의 반복으로 최종적으로 상대의 데이터가 도착한다.

* IP주소의 표기방법
    * 32비트의 디지털 데이터이다.
    * 8비트씩 점으로 구분하여 10진수로 표기한다.
    * 이 형태가 보통 IP 주소이다.
    * 이것만으로는 어느 부분이 네트워크 번호인지 또는 호스트 번호인지 알 수 없다.
    * IP주소의 규칙에서는 네트워크 번호와 호스트 번호의 두 가지를 합쳐서 32비트로 한다는 것만이 결정되어 있을 뿐 내역은 결정되어 있지 않다.
    * 즉 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있다는 것이다.
    * 그러므로 이 내역을 나타내는 정보를 필요에 따라 IP주소에 덧붙인다.
    * 이 정보를 넷마스크 라고 한다.
        * 넷마스크
            * 32비트의 부분이 디지털 데이터로 되어있다,
            * 왼쪽에 1이 나열되고 오른쪽에 0이 나열된 값이 된다.
            * 그리고 넷마스크가 1인 부분이 네트워크 번호를 나타낸다.
            * 0인 부분은 호스트 번호를 나타낸다.
            * 이 넷마스크를 IP주소와 같이 8비트씩 구분하여 표기하고 IP주소의 오른쪽에 병기할 수 있다.
                ex) 10.11.12.13/255.255.255.0
            * 이렇게 표기하면 너무 길어지므로 한 부분의 비트 수를 10진수로 나타내고 IP 주소의 오른쪽에 병기할 수 있다.
                ex) 10.11.12.13/24
            * 두 표기는 방법이 다를 뿐 의미는 같다.
        * 호스트 번호 부분의 비트 값이 모두 0 또는 1인 경우는 특별한 의미를 가진다.
        * 호스트 번호 부분이 모두 0인 IP주소는 각각의 기기를 나타내는 것이 아니라 서브넷 자체를 나타낸다.
        * 호스트 번호 부분이 모두 1이면 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트를 나타낸다.

* 도메인명과 IP주소를 구분하여 사용하는 이유
    * TCP/IP의 네트워크는 IP주소로 통신 상대를 지정하므로 IP 주소를 모르면 상대에게 메시지를 전달할 수 없다.
    * 그러므로 OS에 메시지 송신을 의뢰할 때는 IP 주소를 조사해야 한다.
    * IP주소를 기억하기 어려우므로 서버의 이름을 사용한다.
    * 도메인명을 IP주소로 하면 비효율적이다.
        * IP주소는 32비트 즉, 4바이트
        * 도메인명은 수십 바이트 부터 최대 255바이트
        * 라우터가 부하되어 데이터를 운반하는 동작에 더 많은 시간이 걸릴것이다.
    * DNS를 이용하면 이름으로 IP주소를, IP주소로 이름을 알 수 있다. 

* Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다.
    * IP 주소를 조사하는 방법은 간단하다. 
    * 즉 가장 가까운 DNS 서버에 도메인이름의 서버의 IP주소를 알려달라고 질문하면 된다.
    * 그러면 DNS서버는 IP주소를 알려준다.
    * DNS 서버에 조회한다는 것은 DNS 서버에 조회 메시지를 보내고, 거기에서 반송되는 응답 메시지를 받는다는 것이다.
    * 이것은 DNS서버에 대해 클라이언트로 동작한다고 말할 수 있다.
    * 이 DNS 클라이언트에 해당하는 것을 DNS 리졸버 또는 단순히 리졸버라고 부른다.
    * 그리고 DNS의 원리를 사용하여 IP 주소를 조사하는 것을 네임 리졸루션이라고 한다.
    * 이 리졸루션을 실행하는 것이 리졸버이다.
        * 리졸버
            * 리졸버의 실체는 Socket 라이브러리에 들어있는 부품화한 프로그램이다.
                * Socket 라이브러리
                    * OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 라이브러리이다.
                    * 데이터를 송, 수신할 때 사용하는 부품을 비롯하여 다수의 프로그램 부품들이 들어있다.
            * 브라우저 등의 애플리케이션 프로그램을 만들 때 리졸버의 프로그램명과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있다.
                * ex) const ip = gethostbyname("www.naver.com")
            * 이렇게 해서 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 보낸다.
            * DNS 서버에서 응답이 돌아온다.
            * 이 응답 메시지 속에 IP 주소가 포함되어 있다.
            * 리졸버는 이것을 추출하여 브라우저에서 지정한 메모리 영역에 넣는다.
            * 브라우저가 웹 서버에 메시지를 보낼때는 이 메모리 영역에서 IP 주소를 추출하여 HTTP의 리퀘스트 메시지와 함께 OS에 건네주어 송신을 의뢰한다.
            * 리졸버의 내부 동작
                * 네트워크 애플리케이션(브라우저)이 리졸버를 호출한다
                * 제어가 리졸버의 내부로 넘어간다.
                    * 제어가 넘어간다.
                        * 애플리케이션 프로그램에 쓰여있는 작업 내용은 보통 위에서 아래로 실행된다.
                        * 이것이 리졸버를 호출하는 부분에 이르러 해당 행을 실행하면 여기에서 애플리케이션의 동작이 일시적으로 정지한다.
                        * 그리고 Socket 라이브러리의 내용에 있는 리졸버가 움직이기 시작한다.
                        * 애플리케이션에서 의뢰받은 작업을 실행한다.
                        * 이와 같이 별도의 프로그램을 호출하여 호출처의 프로그램이 쉬고 있는 상태가 되며, 호출한 대상 프로그램이 움직이기 시작하는 것을 '제어가 넘어간다'고 한다.
                * 리졸버에서 제어가 넘어가면 여기에서 DNS 서버에 문의하기 위한 메시지를 만든다.
                * 이것은 브라우저가 웹 서버에 보내는 HTTP의 리퀘스트 메시지를 만드는 것과 유사하다.
                * 메시지를 DNS 서버에 보낸다.
                * 메시지 송신 동작은 리졸버가 스스로 실행하는 것이 아니다.
                * OS의 내부에 포함된 프로토콜 스택을 호출하여 실행을 의뢰한다.
                    * 프로토콜 스택 
                        * OS 내부에 내장된 네트워크 제어용 소프트웨어이다.
                        * 프로토콜 드라이버, TCP/IP 소프트웨어 등으로도 불린다.
                * 리졸버도 브라우저와 같이 네트워크에 대해 데이터를 송, 수신 하는 기능이 없기 때문이다.
                * 리졸버가 프로토콜 스택을 호출하면 제어가 리졸버에게 넘어간다.
                * 여기에서 메시지를 보내는 동작을 실행한다.
                * LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신된다.
                * 그러면 조회 메시지가 DNS 서버에 도착한다.
                * DNS서버는 메시지에 쓰여있는 조회 내용을 조사하여 답을 찾는다.
                * 액세스 대상의 웹 서버가 DNS 서버에 등록되어 있으면 답이 발견되므로 답을 응답 메시지에 써서 클라이언트에게 반송한다.
                * 그러면 메시지는 네트워크를 통해 클라이언트 측에 도착한다.
                * 프로토콜 스택을 경유하여 리졸버에게 건네준다.
                * 리졸버가 이 내용을 해독한 후 여기에서 IP 주소를 추출하여 애플리케이션에 건네준다.
                * 실제로는 리졸버를 호출할 때 지정한 메모리 영역에 IP 주소를 저장한다.
                * 이로써 리졸버의 동작이 끝나고 제어가 애플리케이션으로 돌아간다.
            * DNS 서버에 메시지를 송신할 때도 DNS 서버의 IP 주소가 필요하다.
            * 단 이것은 TCP/IP 설정 항목의 하나로 컴퓨터에 미리 설정되어 있다.
            * TCP/IP 설정 밥법은 OS의 종류에 따라 다르다.
            * 리졸버는 여기서 설정한 DNS 서버의 IP 주소에 조회 메시지를 보낸다고 생각하면 된다.

* DNS
    * DNS 서버의 기본 동작
        * DNS 서버의 기본 동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.
        * 조회 메시지에는 다음의 세 가지 정보가 포함되어 있습니다.
            * 이름
                * 서버나 메일 배송 목적지(@ 뒷부분)와 같은 이름
            * 클래스
                * DNS의 구조를 고안했을 때 인터넷 이외에도 네트워크에서의 이용 까지 검토하여 이것을 식별하기 위해 클래스라는 정보를 준비했다.
                * 그러나 지금은 인터넷 이외의 네트워크는 소멸되었다.
                * 클래스는 항상 인터넷을 나타내는 'IN'이라는 값이 된다.
            * 타입
                * 이름에 어떤 타입의 정보가 지원되는지를 나타낸다.
                    * 예를 들면 A이면 이름에 IP 주소가 지원되는 것을 나타낸다
                    * MX이면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다.
                * 이 타입에 따라 클라이언트에 회답하는 정보의 내용이 달라진다.
        * DNS 서버에는 이들 세 가지 정보에 대응하여 클라이언트에 회답하는 항목을 등록해 두었다.
        * 이 등록 내용에서 조회 메시지에 해당하는 것을 클라이언트에게 회답한다.
        * 최초에 www로 시작하는 이름을 붙인 것이 많지만, 모두 이런 규칙이 있는 것은 아니다.
        * 최초에 웹의 구조를 만들 때 'www' 이라는 이름으로 웹 서버를 등록한 것이 많았기 때문에 이것이 관례가 된 것 뿐이다.
    |이름|클래스|타입|클라이언트에 회답하는 항목|
    |--|--|--|--|
    |www.naver.con|IN|A|125.209.222.141| 

    * 도메인의 계층
        * 사내 네트워크처럼 웹 서버나 메일 서버의 수가 제한되어 있으면 정보를 전부 한대의 DNS 서버에 등록할 수 있다.
        * 그러나 인터넷에는 막대한 수의 서버가 있으므로 이것을 전부 1대의 DNS 서버에 등록하는 것은 불가능하다.
        * 이를 위해 정보를 분산시켜 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되아 있는지를 찾아내는 구조이다.
        * 우선 DNS 서버에 등록한 정보에는 모든 도메인명이라는 계층적 구조를 가진 이름이 붙여져있다.
        * DNS에서 취급하는 이름은 점으로 구분되어 있는데, 이 점이 계층을 구분한다.
        * 그리고 오른쪽에 위치한 것이 상위의 계층을 나타낸다.
        * 점 으로 구분되는 하나하나를 도메인이라고 부른다.
            * ex) www.naver.com -> com 이라는 도메인 아래 naver 라는 도메인이 있고, 그 아래 www라는 도메인 이있다.
        * 이렇게 계층화된 도메인의 정보를 서버에 등록한다.
        * 이때 하나의 도메인을 일괄적으로 취급한다.
        * 즉, 한 개의 도메인 정보를 일괄적으로 DNS 서버에 등록하고 도메인 한 대의 정보를 분할하여 복수의 DNS 서버에 등록하는 것은 불가능하다.
        * 단 DNS 서버와 도메인은 항상 1 대 1이 아니라 한 대의 DNS 서버에 복수의 도메인의 정보를 등록할 수 있다.
        * 즉, 한 대의 DNS 서버에 도메인 한 대를 등록한다고 생각해도 좋다. 
        * 이제 한 대의 DNS 서버에 도메인 한 대를 등록하는 것으로 가정해보자
        * 그러면 도메인의 계층 구조와 같은 형태로 DNS 서버가 배치된다.
        * 각 도메인의 정보는 그 도메인에 있는 DNS 서버에 등록된다.
    * 담당 DNS 서버를 찾아 IP 주소를 가져온다.
        * 인터넷에슨 DNS 서버가 수만 대나 있으므로 닥치는 대로 뒤지면서 다닐 수는 없다.
        * 먼저 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록한다.
            * ex) www.naver.com 이라는 도메인을 담당하는 DNS 서버를 naver.com의 DNS 서버에 등록한다.
            * naver.com의 DNS 서버를 com의 DNS 서버에 등록한다.
        * 이렇게 하면서 상위의 DNS 서버에 가면 하위의 DNS 서버의 IP 주소를 알 수 있다.
    * 루트 도메인
        * com이나 kr 상위에 존재하는 도메인이다.
        * 루트 도메인에는 도메인명이 없으므로 보통 도메인을 쓸때는 생략한다.
        * 하지만 루트 도메인을 명시적으로 써야 하는 경우에는 www.naver.com. 처럼 끝에 마침표를 찍어서 루트 도메인을 나타낸다.
        * 보통은 그렇게 쓰지 않으므로 루트 도메인의 존재를 알아차리지 못한다.
        * 이 경우 루트 도메인이 존재하므로 DNS 서버에 com, kr의 DNS 서버를 등록한다.
        * 이렇게 해서 하위의 DNS 서버를 상위의 DNS 서버에 등록하여 루트 도메인에서 차례로 아래쪽으로 거슬러 내려갈 수 있다.
        * 등록 작업은 한가지 더 있다.
        * 루트 도메인의 DNS 서버를 인터넷에서 존재하는 DNS 서버에 전부 등록하는 것이다.
        * 이렇게 해서 어느 DNS 서버도 루트 도메인에 엑세스 할 수 있게 된다.
        * 그 결과, 클라이언트에서 어딘가의 DNS 서버에 액세스하면 여기에서부터 루트 도메인을 경유하여 도메인의 계층 아래로 찾아가서 최종적으로 원하는 DNS 서버에 도착하게 된다.
        * 루트 도메인의 DNS 서버에 할당된 IP 주소는 전 세게에 13개 밖에 없고 좀처럼 변경되지 않는다.
        * 따라서 이것을 각 DNS 서버에 등록하는 작업은 어렵지 않다.
        * 실제로 루트 도메인의 DNS 서버에 관한 정보는 DNS 서버 소프트웨어와 함께 설정 파일로 배포되어 있으므로 DNS 서버 소프트웨어를 설치하면 자동으로 등록이 완료된다.
    * 여기까지가 준비단계이다.
    * 이로써 DNS 서버는 수만대 이상 있는 DNS 서버 중에서 원하는 DNS 서버를 찾아낼 수 있다.
    * 과정 (브라우저가 gethostbyname을 호출하여 웹 서버의 주소를 조사하는 동안의 동작의 일부의 시작과 끝)
        * 클라이언트가 가장 가까운 DNS서버에게 www.naver.com을 요청한다.
        * 루트 도메인에게 해당 도메인이 있는지를 물어본다.
        * com 도메인의 DNS 서버에게 문의하라고 회신을 준다.
        * 가장 가까운 DNS 서버가 이번에는 루트 DNS서버에서 회신해준 com 도메인의 DNS서버로 www.naver.com을 요청한다.
        * naver.com 도메인의 DNS 서버 주소에게 물어보라고 회신해준다.
        * naver.com 도메인의 DNS 서버에게 www.naver.com을 요청한다.
        * naver.com 도메인의 DNS 서버에는 www.naver.com의 IP주소를 알고 있기 때문에 이 IP를 회신해준다.
        * 가장 가까운 DNS 서버는 IP를 회신받아 클라이언트에게 회신해준다.
        * 이로써 클라이언트는 웹 서버의 IP 주소를 알고 거기에 액세스 할 수 있게 된다.
    * DNS서버는 캐시 기능으로 빠르게 회답할 수 있다.
        
* 데이터 송, 수신 동작의 개요
    * IP 주소를 조사했으면 IP 주소의 상대, 여기에서는 액세스 대상 웹 서비스에 메시지를 송신하도록 OS 내부에 있는 프로토콜 스택에 의뢰한다.
    * 웹 서버에 보내는 HTTP의 메시지는 디지털 데이터이므로 디지털 데이터르 송신하도록 의뢰해야한다.
    * 또한 디지털 데이터를 송, 수신 하는 동작은 브라우저뿐만 아니라 네트워크를 이용하는 애플리케이션 전체에 공통이다.
    * 그러므로 이 동작은 웹에 한정되지 않고 모든 네트워크 애플리케이션에 해당된다.
    * 여기에서도 DNS 서버에 IP 주소를 조회할 떄와 같이 Socket 라이브러리에 들어있는 프로그램 부품을 이용한다.
    * IP 주소를 조회할 때처럼 프로그램 부품을 하나씩 호출하고 끝나지는 않는다.
    * 복수의 부품을 결정된 순번대로 호출해야 하므로 조금 복잡하다.
    * 데이터를 송, 수신하는 컴퓨터 사이에 데이터의 통로 같은 것이 있다.
    * 이것을 통해 데이터가 흐르면서 상대측에 도착한다.
    * 통로의 양 끝에 있는 데이터의 출입구를 소켓이라고 부른다.
    * 우선 이 소켓을 만들고 연결한다.
    * 실제로는 먼저 서버측에서 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다린다.
    * 이렇게 해서 서버측이 기다리고 있는 동안에 클라이언트측에서 파이프를 연결한다.
    * 클라이언트 쪽에서 소켓을 맏늘고, 소켓에서 파이프를 늘려 서버측의 소켓에 연결하는 것이다.
    * 이로써 양쪽의 소켓이 연결되면 준비가 완료된 것이다.
    * 데이터를 전부 보내고 나면 연결했던 파이프가 분리된다.
    * 파이프를 연결할 떄는 클라이언트측에서 서버측을 향하여 연결했지만, 파이프를 분리할 때는 어느쪽에서 분리해도 상관없다.
    * 한쪽에서 분리하면 또 한쪽도 분리되고, 파이프를 분리하면 소켓을 말소하여 통신 동작이 종료된다.
    * 이 단계에 따라 Socket 라이브러리 안의 프로그램 부품을 호출하여 데이터의 송, 수신 동작을 실행한다.
    * 이 동작들을 실행하는 것은 OS 내부의 프로토콜 스택이다.
    * 브라우저 등의 애플리케이션은 자체에서 파이프를 연결하거나 거기에 데이터를 보낼 수 없다.
    * 프로토콜 스택에 의뢰해서 파이프를 연결하거나 데이터를 보낸다.
    * 의뢰 동작은 Socket 라이브러리에 넣은 프로그램 부품을 호출하여 실행되지만, 데이터 송, 수신용 프로그램 부품은 애플리케이션에서 의뢰받은 내용을 그대로 프로토콜 스택에 전달하는 중개역을 수행할 뿐 실질적인 작업은 하지 않는다.
    * 그렇기 때문에 프로그램 부품의 동작이 어떤 것인지를 알기 쉽게 보여줄 수 없다.

* 소켓의 작성 단계
    * 먼저 소켓을 만들어야 한다. (socket)
        * 소켓 라이브러리의 socket이라는 프로그램 부품만 호출하면 된다.
        * socket을 호출한 후의 동작은 socket 내부에 제어가 넘어가서 소켓을 만드는 동작을 실행한다.
        * 소켓이 생기면 디스트립터라는 것이 돌아온다.
        * 애플리케이션은 이것을 받아서 메모리에 기록해둔다.
            * 디스트립터       
                * 소켓을 식별하기 위해 사용하는 것이다.
                * 컴퓨터 내부에서는 복수의 데이터 송, 수신이 일어날 수 있기 때문에 식별이 필요하다.
                * 소켓일 만든 후 이것을 사용하여 접속 동작이나 데이터 송, 수신 동작으 실행하는데, 이때 디스크립터를 보여주면 프로토콜 스택이 어느 소켓을 사용하여 접속할지 또는 데이터를 송, 수신할지를 금방 판단할 수 있다.
    * 파이프를 연결하는 접속 단계 (connect)
        * connect를 호출하여 이 의뢰 동작을 실행한다.
        * connect를 실행할때는 디스크립터, 서버의 IP 주소, 포트 번호 3가지의 값이 필요하다.
            * 디스크립터
                * 디스크립터는 connect가 프로토콜 스택에 통지한다.
                * 그리고 프로토콜 스택이 통지받은 디스크립터를 보고 어느 소켓을 서버측의 소켓에 접속할지 판단하여 접속 동작을 실행한다.
            * IP주소
                * DNS서버에 조회하여 조사한 액세스 대상 서버의 IP 주소이다.
            * 포트 번호
                * IP주소로는 네트워크의 어느 컴퓨터인가 까지 알 수 있다.
                * IP주소로는 소켓까지 지정할 수 없다.
                * 그렇기 때문에 포트 번호가 필요하다.
                * IP주소와 포트번호를 이용해 어느 컴퓨터의 어느 소켓과 접속할지를 분명히 지정할 수 있다.
                * 서버측의 포트 번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다는 규칙이 있다.
                    * 웹은 80, 메일은 25번...
                * 서버 측에서도 클라이언트측의 포트 번호를 알아야 한다.
                    * 먼저 클라이언트측의 소켓의 포트 번호는 소켓을 만들 때 프로토콜 스택이 적당한 값을 골라서 할당한다.
                    * 그리고 이 값을 프로토콜 스택이 접속 동작을 실행할 때 서버측에 통지한다.
        * connect를 호출하면, 프로토콜 스택이 접속 동작을 실행한다.
        * 그리고 상대와 연결되면 프로토콜 스택은 연결된 상대의 IP주소나 포트 번호등의 정보를 소켓에 기록한다.
        * 이로써 데이터 송, 수신이 가능한 상태가 된다.
        * 디스크립터
            * 애플리케이션이 소켓을 식별하는 것
        * IP와 포트
            * 클라이언트와 서버 간에 상대의 소켓을 식별하는 것

    * 메시지를 주고받는 송, 수신 단계 (write, read)
        * 소켓이 상대측과 연결되면 그 다음은 간단하다.
        * 소켓에서 데이터를 보내면 상대측의 소켓에 데이터가 도착한다.
        * 그러면 애플리케이션은 소켓을 직접 다룰 수 있으므로 Socket 라이브러리를 통해 프로토콜 스택에 그 일을 의뢰한다.
        * 그래서 write 라는 프로그램 부품을 사용한다.
            * 우선 애플리케이션은 송신 데이터를 메모리에 준비한다.
            * 사용자가 입력한 URL을 바탕으로 만든 HTTP 리퀘스트 메시지가 여기에서 말하는 송신 데이터이다.
            * 그리고 write를 호출할 때 디스크립터와 송신 데이터를 지정한다.
            * 그러면 프로토콜 스택이 송신 데이터를 서버에게 송신한다.
            * 소켓에는 연결된 상대가 기록되어 있으므로 디스크립터로 소켓을 지정하면 연결된 상대가 판명이 되어 그곳을 향해 데이터를 송신한다.
            * 이 송신 데이터는 네트워크를 통해 전부 그대로 액세스 대상의 서버에 도착한다.
            * 그러면 서버는 수신 동작을 실행하여 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메시지를 반송한다.
        * 이 메시지가 돌아오면 이번에는 메시지를 송신하는 동작이 필요하다.
        * 수신할 때는 Socket 라이브러리의 read를 사용하여 프로토콜 스택에 수신 동작을 의뢰한다.
        * 이떄 수신한 응답 메시지를 저장하기 위한 메모리 영역을 지정하는데, 이 메모리 영역을 수신 버퍼라고 부른다.
        * 그러면 응답 메시지가 돌아올 떄 read가 받아서 수신 버퍼에 저장한다.
        * 수신 버퍼는 애플리케이션 프로그램 내부에 마련된 메모리 영역이므로 수신 버퍼에 메시지를 저장한 시점에서 메시지를 애플리케이션에 건네준다.
    * 연결 끊기 단계에서 송, 수신이 종료된다. (close)
        * 브라우저가 데이터 수신을 완료하면 송, 수신 동작은 끝이난다.
        * 그 후 Socket 라이브러리의 close라는 프로그램 부품을 호출하여 연결 끊기 단계로 들어가도록 의뢰한다.
        * 그러면 소켓 사이를 연결한 파이프와 같은 것이 분리되고 소켓도 말소된다.
        * 웹에서 사용하는 HTTP프로토콜에서는 본래 응답 메시지의 송신을 완료했을 때 웹 서버측에서 연결 끊기 동작을 실행하므로 먼저 웹 서버측에서 close를 호출하여 연결을 끊는다.
        * 이것이 클라이언트측에 전달되어 클라이언트의 소켓은 연결 끊기 단계로 들어간다.
        * 그리고 브라우저가 read로 수신 동작을 의뢔했을 때 read는 수신한 데이터를 건네주는 대신 송, 수신 동작이 완료되어 연결이 끊겼다는 사실을 브라우저에게 통지한다.
        * 이로써 송, 수신이 종료되었다는 것을 알 수 있으므로 브라우저에게서도 close를 호출하여 연결 끊기 단계에 들어간다.
    * 서버에서 복수의 데이터를 읽을 때 연결 끊기를 반복하는 것은 비효율적이므로 한 번 접속한 후 연결을 끊지 않고 복수의 리퀘스트와 응답 주고받기를 실행하는 방법이 마련되었다.
    * HTTP의 버전 1.1 에서 이 방법을 사용할 수도 있다.
    * 이 경우 리퀘스트해야 할 데이터가 없어진 상태에서 브라우저에게서 연결 끊기 동작에 들어갈 수 있다.
    * 메시지를 실제로 송, 수신 하는 것은 프로토콜 스택, LAN 드라이버, LAN 어댑터 3가지이다.
    

