* 운영체제란?

    * 하드웨어 바로 윗단에 설치되는 소프트웨어이다.
    * 좁은 의미에서는 커널을 의미한다.
    * 넓은 의미에서는 커널 뿐만 아니라 주변 시스템 유틸리티를 포함한 개념으로 말할 수 있다.
    * 하드웨어 측면에서의 역할
        * 실행되는 응용 프로그램들이 메모리와 CPU, 입출력 장치들을 사용할 수 있도록 만들어준다.
        * 컴퓨터의 자원을 효율적으로 관리한다.
        * 컴퓨터의 자원을 형평성 있게 분배한다.    
    * 사용자 측면에서의 역할
        * 사용자가 쉽게 컴퓨터를 사용할 수 있도록 환경 제공한다.
        * 실행되고 있는 프로그램 중 사용자의 요청에 맞는 화면을 보여준다.        
        * 여러 개의 응용 프로그램을 실행하고 있는 동안 동시에 수행되는 것 처럼 보이도록 스케줄링을 한다.
    
* 운영체제가 구체적으로 하는 일
    * CPU Scheduling
        * 어떤 Process에 CPU를 할당할지 결정한다.
    * 메모리 관리
        * 유한한 RAM에서 동시에 여러 프로그램을 실행시키기 위해 메모리를 관리한다.
    * 디스크 관리
        * 유한한 디스크를 효율적으로 사용하기 위해 관리한다.
    * 입출력 관리
    * 프로세스 관리

* 셸
    * 사용자의 입력을 받아 시스템 기능을 수행하는 명령어 해석기
    * 사용자가 시스템은 운용할 수 있게끔 해주는 기본적인 응용 프로그램
    * 운영체제에 명령을 내린다.
    * bash는 엄밀히 운영체제의 일부가 아니며, 운영체제 입장에서는 셸이나 필수 유틸리티 모두 응용프로그램일 뿐이다.

* 커널
    * 시스템의 모든 것을 완전히 통제한다.
    * 운영체제의 핵심 부분으로 주기억 장치에 상주한다.
    * 주소 공간을 가지고 있어 데이터를 저장할 수 있다.
    * 시스템 콜을 저장하는 커널 스택이 있다.
        * 시스템 콜
            * 운영체제에게 어떠한 요청을 하는 것
            * 사용자 프로그램이 운영체제의 서비스를 받기 위해 함수를 호출하는 것이다.
    * 응용 소프트웨어를 컴퓨터 하드웨어에 연결한다.
    * 운영체제 맨 하부에 들어간다.
    * 얼마나 메모리를 읽고 쓸 것인지, 어느 프로세스를 실행할 것인지, 모니터, 키보드, 마우스와 같은 장치를 통해 어떠한 정보를 주고 받을 것인지, 네트워크를 통해 받은 정보를 어떻게 해석할 것인지를 제어한다.
    * 하드웨어 추상화
        * 같은 종류의 장치일지라도 다양한 하드웨어 설계가 존재한다.
        * 커널은 펌웨어와 장치 드라이버의 도움을 받아 모든 컴퓨터 하드웨어 장치에 대한 가장 기초 수준의 제어권을 제공한다.
            * 드라이버
                * 컴퓨터에 설치된 하드웨어를 OS에 연결하기 위한 프로그램
                * 드라이버는 커널을 마음대로 손댈 수 있다.
            * 펌웨어
                * 전자기기에 공장 출시시 설치되는 마이크로 프로그램
                * 줄 하드웨어를 제어하여 어플리케이션 설치를 통해 기능을 추가한다
        * 여러 응용프로그램들이 하드웨어들 위에서 돌아가도록 호환성을 보장하기 위해 API를 제공한다.
        * ex) 웹 브라우저가 화면에 점을 찍고 싶다.
            * 커널에서 제공하는 점을 찍는 함수를 사용
            * 커널이 드라이버를 참조해서 그래픽 카드에 명령해 점을 찍도록 한다.

* 프로세스
    * 프로그램은 명령어(코드)와 정적인 데이터의 묶음이다.
    * 프로그램은 보조 기억장치에 존재하며 실행되기를 기다린다.
    * 이 프로그램이 실행되어 주기억 장치에 적재되면 프로세스가 된다. (주기억 장치에 주소 공간을 갖게된다.)   
    * 운영체제가 관리하는 최소 단위 작업이다.
    * 구성
        * 실행 코드를 저장하는 텍스트
        * 정적 변수를 저장하는 데이터
        * 동적할당영역을 저장하는 실행 힙
        * 함수의 복귀 주소 및 지역변수를 저장하는 영역인 스택
    * PCB
        * 프로세스가 생성될 때 마다 고유의 PCB가 생성되고, 프로세스가 종료되면 제거된다.
        * 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조이다.
        * 커널 주소 공간에서 data에 해당하는 부분에 저장된다.
        * 프로세스의 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 하는데, 이때의 작업의 진행 상황을 모두 PCB에 저장하게 된다.
    * 프로세스의 상태
        * 커널 내에는 준비 큐, 대기 큐, 실행 큐 등의 자료구조가 있다.
        * 커널은 이것들을 이용하여 프로세스의 상태를 관리한다.
        * Create
            * 프로세스가 생성되는 중이다.
        * Ready
            * 프로세스가 CPU를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태이다.        
        * Running
            * 프로세스가 CPU를 차지하여 명렁어들이 실행되는 중이다.
        * Waiting/Blocked
            * 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태이다.
        * Termiated
            * 프로세스의 실행이 종료되었다.
    * 프로세스의 상태전이
        * 하나의 프로그램이 실행되면 그 프로그램에 대응되는 프로세스가 생성되어 준비 리스트 끝에 들어간다.
        * Submit
            * 장기스케줄러에 의해 실행된 프로세서는 Ready Queue(주기억 장치)로 적재된다.
        * Dispatch
            * 단기스케줄러에 의해 Ready Queue 맨 앞에 있던 프로세스가 CPU를 점유하게 된다.
        * Block
            * 실행 상태의 프로세스가 허가된 시간을 다 쓰기 전에 입출력 동작을 필요로 하는 경우 프로세스는 CPU를 스스로 반납하고 보류 상태로 넘어간다.
        * Wakeup
            * 입출력 작업 종료 등 기다리던 사건이 일어났을 때 보류 상태에서 준비 상태로 넘어간다.
        * Timeout
            * 운영체제는 프로세스가 프로세서를 계속 독점해서 사용하지 못하도록 click interrupt를 두어 프로세스가 일정 시간동안만 프로세서를 점유할 수 있게 한다.

        
* 스케줄러
    * 프로세스를 스케줄링하기 위한 Queue
        * Job Queue
            * 현재 시스템 내에 있는 모든 프로세스의 집합을 의미한다.
        * Ready Queue
            * 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합을 의미힌다.
        * Device Queue
            * Device I/O 작업을 대기하고 있는 프로세스의 집합을 의미한다.
    * 장기스케줄러 (Long-term scheduler or Job Scheduler)
        * 주기억 장치는 한정되어 있는데 많은 프로세스들이 한꺼번에 주기억 장치에 올라올 경우, 디스크에 임시로 저장된다.
        * 이 Spool에 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 Ready Queue로 보낼지 결정하는 역할을 한다.
        * 작업이 메모리에 올라갈 준비가 되어 있을 때 거치는 스케줄링
        * 프로세스에 메모리를 할당 (submit)
    * 단기스케줄러 (Short-term scheduler or CPU Scheduler)
        * CPU와 주기억 장치 사이의 스케줄링을 담당한다.
        * Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 runnig 시킬지 결정한다.
        * 프로세스에 CPU를 할당 (dispatch)
    * 중기스케줄러 (Medium-term Scheduler or Swapper)
        * 여유 공간의 마련을 위해 프로세스를 주기억 장치에서 디스크로 쫒아낸다 (swapping)
        * 프로세스에서 메모리를 해제
    * CPU 스케줄링 알고리즘
        * 스케줄링 대상은 Ready Queue에 에 있는 프로세스들이다.
        * 다중 프로그래밍 방식은 메모리에 여러 개의 프로그램을 적재함으로써 CPU와 I/O 장치들의 유휴시간을 줄여 사용 효율을 높이는 방식이다.
        * 이러한 다중 프로그래밍 방식에서 CPU의 사용률과 처리율을 최대화 하기 위한 방법들이다.
        * 비선점형과 선점형
            * 비선점형
                * 프로세스가 CPU에 할당되면 권한을 빼앗을 수 없다.
                * FIFO, SJF, HRN, 우선순위, 기한부 방식이 있다.
                * 문맥 교환이 적어 오버헤드가 적다.
                * FIFO(FCFS)
                    * 먼저 입력된 작업을 먼저 처리한다.
                * SJF(Shortest Job First)
                    * 작업이 끝나기까지의 실행 시간 추정치가 가장 작은 작업을 먼저 실행시킨다.
                    * 에이징 기법을 통해 무한 연기를 예방한다.
                        * 오래 기다린 프로세스는 기다린 시간에 비레하는 높은 우선순위를 부여하는 기법이다.
                * HRN(Highest Response-ratio Next)
                    * 서비스 시간과 대기 시간의 비율을 고려한 스케줄링 방법이다.
            * 선점형
                * 프로세스가 CPU에 할당될 때, 우선순위가 높으면 빼앗을 수 있다.
                * RR, SRT, MFQ 방식이 있다.
                * 문맥 교환이 많아 오버헤드가 많다.
                * 라운드 로빈
                    * 시분할 시스템을 위해 고안되었다.
                    * 여러 개의 프로세스가 10~100msec 정도의 시간 할당량이라는 작은 단위 시간이 정의되어 시간 할당량만큼씩 CPU를 사용하는 방법이다.
                * SRT(Shortes Remaining Time)
                    * 작업이 끝나기까지 남아있는 실행 시간의 추정치가 가장 작은 프로세스를 먼저 실행하는 방식으로 새로 입력되는 작업까지 포함한다.

* 인터럽트
    * 인터럽트를 감지하면 실행중인 기계어 코드를 중단하고 해당 인터럽트를 위한 처리 프로그램으로 점프하여 일을 수행한다.
    * 인터럽트 동작 순서
        * 인터럽트가 발생한다.
        * CPU가 인터럽트를 확인하고 프로그램 실행을 중단한다.
        * 문맥 교환이 일어난다.
            * 실행되고 있는 프로세스의 PC(program counter), SR(status register)을 스택(kernel mode stack)에 저장한다.
        * PC에 인터럽트 벡터를 적재함으로써 인터럽트 서비스 루틴을 실행한다.
            * 인터럽트 벡터는 인터럽트가 발생했을 때 해야 할 일이 무엇인가를 정해놓은 것이다.
            * 인터럽트 서비스 루틴의 시작 주소이다
                * 인터럽트 서비스 루틴은 인터럽트를 처리하는 함수이다.           
        * 인터럽트의 종류에 따라 알맞은 인터럽트 서비스 루틴을 실행한다.
            * 인터럽트 원인을 파악하고 실질적인 작업을 수행한다.
            * 우선 순위가 더 높은 인터럽트가 발생하면 위의 과정을 반복한다.
        * 스택에 저장하였던 레지스터를 복구한다.
        * 인터럽트 서비스 루틴 끝에 RETI 명령어를 실행하여 SR과 PC를 복구한다.
        * 중단된 프로그램 실행 재개
    * 인터럽트 우선순위
        * 전원 이상 > 기계 착오 > 외부 신호 > 입출력 > 명령어 잘못 > 프로그램 검사 > SVC
    * 문맥 교환
        * CPU를 어떤 프로세스에서 다른 프로세스로 넘겨주는 과정이다.
        * 다중 프로그램이 시스템에서 CPU가 할당되는 프로세스를 변경하기 위하여 현재 CPU를 사용하여 실행되고 있는 프로세스의 상태 정보를 저장하고 제어권을 인터럽트 서비스 루틴에게 넘기는 작업이다.
            * 인터럽트 서비스 루틴 = 인터럽트 핸들러
            * 인터럽트에 대응하여 특정 기능을 처리하는 기계어 코드 루틴이다.
            * 커널에 존재한다.
        * 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업이다.
        * 한 프로세스의 문맥은 그 프로세스의 PCB에 기록되어 있다.
        * 프로세스의 실행을 위한 부가적은 활동을 오버헤드라고 하는데, 이 또한 문맥 교환 수와 같이 늘어난다.

    
    
* 임계 구역
    * 다중 프로그래밍 운영체제에서 한순간에 여러 개의 프로새스에 의해 공유되는 데이터 및 자원에 대하여 반드시 하나의 프로세스에 의해서만 자원 또는 데이터가 사용되도록 하는 것이다.
    * 여러 개의 프로세스가 공동으로 사용하는 CPU, 메모리, 디스크, 입출력 장치 등을 임계구역이라 할 수 있다.
    * 임계 구역의 원칙
        * 두 개 이상의 프로세스가 동시에 사용할 수 없다.
        * 순서를 지키며 신속하게 사용한다.
        * 하나의 프로세스가 독점하게 해서는 안된다.
        * 인터럽트가 불가능한 상태로 만들어야 한다.
    * 상호배제 (Semaphore)
        * 임계 구역을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 하며, 다른 프로세스가 현재 사용 중인 임계 구역에 대하여 접근하려고 할 때 금지하는 행위이다.
        * 상호배제 알고리즘
            * 인터럽트 불능 처리
                * 하나의 프로세스가 임계 구역을 점유하게 되면 인터럽트를 발생하지 않도록 봉쇄한다.
                * 시스템 효율이 떨어진다.
            * 세마포어
                * 리소스의 상태를 나타내는 간단한 카운터라고 할 수 있다.
                * 운영체제 또는 커널의 한 지정된 저장장치 내 값으로, 각 프로세스는 이를 확인하고 변경할 수 있다.
                * 상호배제 및 동기화 문제 해결 방법이다.
                * 이진 세마포어
                    * 잠금
                        * 임계 구역을 점유하게 되는 경우, 그 자원을 어떠한 프로세스도 접근하지 못하도록 하는 방법이다.
                        * 임계 구역을 사용하기 위해 접근하고 있는 임의의 프로세스들은 잠금을 계속 확인하는데, 이를 바쁜 대기 상태라고 한다.
                    * 엄격한 교대
                        * 두 개 이상의 프로세스가 교대로 공유 자원을 점유하는 방식이다.
                        * 한쪽이 작업량이 많아서 빈번해져도 반드시 교대로 점유해야 한다.
                * 산술 세마포어
    * 교착상태 (Dead-Lock)
        * 두 개 이상의 프로세스가 하나의 자원을 공유하여 사용하고 있을 때, 서로가 사용중인 자원을 요구하지만, 요구를 영원히 들어줄 수 없는 상태를 말한다.
        * 교착 상태 발생 필수 4대 조건
            * 상호배제
            * 점유와 대기
            * 비선점
            * 순환 대기

* 가상 기억 장치
    * 주기억 장치 안의 프로그램의 양이 많아질 때, 사용하지 않는 프로그램을 보조 기억 장치 안의 특별한 영역으로 옮겨서, 그 보조 기억 장치의 부분을 주기억 장치처럼 사용하는 것이다.
    * 프로그램 실행시 요구되는 블록만 주기억 장치에 불연속적으로 할당하여 사용한다.
    * 가상으로 주어진 주소를 가상 주소, 혹은 논리 주소 라고 한다.
    * 단편화 문제를 적극적으로 해결할 수 있다.
    * 고정 분할 기법 (Paging)
        * 주기억 장치와 프로그램의 크기를 고정으로 분할한다.
        * 디스크에 존재하는 분할된 프로그램과 주기억 장치에 분할된 영역과 교체되면서 프로그램이 실행된다.
        * 외부 단편화는 존재하지 않지만, 내부 단편화는 페이지의 마지막에 한 번 발생한다.
        * 페이지 사상이 필요하다.
    * 페이지 부재
        * 프로그램에서 접근하려고 하는 페이지가 주기억 장치에 있지 않은 경우에 발생하는 현상이다.
    * 구역성
        * 프로그램이 실행할 떄 기억장치 내의 모든 정보를 균일하게 참조하는 것이아니라 어느 한 순간에 특정 부분을 집중적으로 참조하는 프로그램의 순차적 성질이다.
        * 한번에 호출된 자료나 명령은 곧 바로 다시 사용될 가능성을 말한다.
        * 시간 구역성
            * 최근에 참조된 기억 장소가 가까운 장래에도 계속 참조될 가능성이 높음을 의미한다.
        * 공간 구역성
            * 하나의 기억 장소가 참조되면 그 근처의 기억 장소가 계속 참조될 가능성이 높음을 의미한다.
    * 작업 집합
        * 프로세스를 효과적으로 실행하기 위해서는 주기억 장치에  유지되어야 하는 패이지들의 집합
        * 자주 참조되는 페이지의 집합은 주기억 장치에 미리 적재해두면 페이지 부재를 최소화할 수 있다.
    * 배치 전략
        * 주기억 장치에 프로그램/데이터 위치를 정하는 전략
        * 최초 적합(First Fit)
            * 배치 가능한 첫 번째 공백에 배치한다.
            * 초기 결정력이 빠르다.
            * 단편화가 많이 발생한다.
        * 최적 적합(Best Fit)
            * 가장 잘 맞는 공백에 배치시킨다.
            * 내부 단편화가 가장 적게 발생한다.
            * 결정력이 가장 느리다.
        * 최악 결정(Worst Fit)
            * 가장 잘 맞지 않는 공백에 배치한다.
    * 교체 전략
        * 주기억 장치 내의 빈 공간 확보를 위해 제거할 프로그램/데이터를 선택하는 전략
        * FIFO
            * 가장 먼저 들어와 있던 페이지를 교체한다.
            * 페이지 교체가 가장 많다.
            * 페이지 부재가 가장 많이 발생한다.
        * LRU(Lesat Recently Used)
            * 참조가 된지 가장 오래된 페이지를 교체한다.
        * LFU(Least Frequently Used)
            * 참조가 된 횟수가 가장 적은 페이지와 교체한다.


    
    




* 기타
    * 부트 로더
        * 컴퓨터가 시동되었을 때 운영 체제에 필요한 조치를 취하고 하드 디스크 드라이브에 기록되어 있는 운영체제를 실행시키는 프로그램이다.
    * 운영체제의 5계층 (커널에 포함됨)
        * 1계층: 프로세서 관리
            * 동기화 및 프로세서 스케줄링
                * Job Scheduling
                * CPU Schedulig
        * 2계층: 메모리 관리
            * 메모리 할당 및 회수
        * 3계층: 프로세스 관리
            * 프로세스 생성 및 제거
        * 4계층: 주변장치 관리
            * 주변장치 상태 파악
        * 5계층: 파일 관리
            * 파일의 생성과 소멸, 파일의 열기 닫기
    * 로더
        * 운영 체제의 일부분
        * 목적 프로그램(기계어로 구성된 파일)을 실행 가능한 파일로 변환하기 위해 주 기억장소를 할당하거나, 여러 개의 목적 프로그램을 연계하여 CPU가 처리될 수 있는 프로그램으로 변환한다.
        * 프로그램 실행을 위해 보조 기억 장치로부터 주기억 장치에 올려놓는 것을 좁은 의미의 로더라고 한다.
        * 적재 뿐 아니라 목적 프로그램들끼리 연결시키거나 주기억 장치를 재배치 하는 등의 포괄적인 작업을 넓은 의미의 로더라고 한다.
            * 할당
                * 목적 프로그램이 실행될 주기억 장치 공간을 확보한다.
            * 연결
                * 여러 개의 독립적인 모듈을 연결한다.
                * 독릭적인 주기억 장치의 일부 공간을 논리적인 주소 공간으로 연결한다.
            * 재배치
                * 프로그램이 주기억 장치 공간 안에서 위치를 변경할 수 있게 한다.
            * 적재
                * 프로그램 전체를 주기억 장치에 한 번에 적재하거나 실행 시 필요한 일부분만을 차레로 적재한다.
    * 프로그램 실행
        * 프로그램을 실행하면 운영체제가 프로세스를 만든다.
        * 커널은 메모리와 다른 자원을 할당하여 프로세스를 만들며, 이로써 멀티태스킹 환경에서 프로세스에 대한 우선 순위를 확립하고, 메모리에 프로그램 코드를 적재하며 프로그램을 실행한다.
        * 프로그램은 사용자 및 장치와 상호작용한 다음 원하는 명령을 수행하게 된다.
        * 운영체제는 프로세스들을 생성하거나 삭제, 중단, 재개 시킨다.
        * 프로세스간의 동기화, 통신, 교착상태 처리에 관한 메커니즘을 제공한다.

        * 다른 버전
            * File System에서 실행 파일이 실행된다.
            * Virtual Memory에 적재된다. (프로그램만의 독자적인 주소 공간이 생성됨)
            * 이 공간은 code / data / stack 으로 나뉘어 형성된다.
            * 그 다음 Physical Memory에 올라간다.
            * 이 때, 프로그램이 통째로 모두 올라가지 않고 지금 당장 실행에 필요한 부분만 올라간다.
            * 메모리 낭비 방지를 위해 필요한 부분만 올리는 것이다.

    https://asfirstalways.tistory.com/115?category=664092
    * CPU의 여정
        * CPU 내부에는 메모리보다 처리 속도가 빠른 Register가 있다.
        * 그 중 다음에 수행할 명령어를 저장하는 PC(Program Counter)가 있다.
        * 이를 통해 명령어를 수행한다.
        * CPU 는 다음 수행할 명령어를 수행하기 전에 인터럽트가 들어온 게 있는지 확인한다.
        * 있다면 작업을 멈추고 제어권을 운영체제에 넘긴다.
        * CPU 안에는 mode bit 과 interrupt line 이 있다.
            * mode bit
                * CPU에서 실행되고 있는 것이 운영체제인지 사용자 프로그램인지 구분해준다.
                * 즉, CPU제어권을 운영체제가 갖고 있는지, 사용자 프로그램이 갖고있는지를 구분하는 것이다.
                * 1이면 사용자 모드로 사용자 프로그램이 CPU 제어권을, 2이면 커널 모드로 사용자 운영체제가 CPU 제어권을 갖고 있는 상태이다. 
            * interrupt line
                * CPU가 instruction을 수행하면서 interrupt가 있는지 확인하는 공간이다.
        * Timer
            * CPU의 time sharing 을 구현하는 방법
            * 하드웨어적으로 인터럽트를 발생시키는 것이다.
            * 특정 프로그램이 CPU를 독점하는 것을 막기 위해 존재한다.
        * DMA controller
            * 수많은 I/O 로부터 수많은 인터럽트를 받게 된다.
            * 이렇게 되면 CPU가 자신의 일을 할 틈도 없이 인터럽트만 받다가 끝날것이다.
            * CPU의 중재 없이 device들로 부터 들어온 인터럽트를 처리하고 완료 신호만 CPU에게 보낸다.
            * 메모리에 직접 접근할 수 있는 컨트롤러이다.
        * Memory Controller
            * 메모리도 하나의 장치이다.
            * 이 컨트롤러는 CPU와 DMA Controller가 메모리에 동시에 접근하는 것을 제어한다.
        * System Call
            * 사용자 프로그램이 돌아가다가 운영체제에게 어떠한 요청을 하는 것을 시스템 콜 이라고 한다.
        
    * 파일 시스템
        * 컴퓨터 시스템의 편리한 사용을 위해 정보를 저장하고 관리하는 시스템
        * 컴퓨터에서 사용되는 파일을 다루는 운영체제의 파일 관리 체제이다.

    * 도메인
        * 도메인 = 객체 + 권한
            * 객체
                * 컴퓨터 시스템에서 보호되어야 할 대상으로 CPU, 메모리, 디스크, 프린트, 프로세스, 파일, 데이터베이스 등을 말한다.
            * 권한
                * 객체를 보호하기 위한 허가 권한으로 읽기(r) 가능, 쓰기/수정(w) 가능, 실행(x) 가능 등이 있다.
        * 자원 보호 기법
            * 컴퓨터 시스템에서 보호되어야 할 모든 대상의 접근 목록을 두어 접근 가능한 사용자와 가능한 동작을 기록한 후, 이를 근거로 접근을 허용하는 기법이다.

    * 주/종 프로세서 구조
        * 하나의 컴퓨터 시스템에 두 개의 프로세서가 있을 경우 입출력과 연산을 각각 독립적으로 수행하지 않고 주 프로세서는 입출력과 연산, 종 프로세서는 연산을 일부 담당하게 한다.
        * 주 프로세서가 중단되면 시스템이 멈추지만, 종 프로세서가 중단되어도 컴퓨터 시스템은 계속 동작한다.