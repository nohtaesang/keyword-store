# You don't know js (타입과 문법, 스코프와 클로저) - 카일 심슨
## 타입
* 어떤 형태로든 거의 모든 자바스크립트 프로그램에서 강제변환이 일어나므로 타입을 확실하게 인지하고 사용하는 것이 중요하다.
* 내장 타입
    * 자바스크립트에는 7 가지 내장 타입이 있다.
        * null
        * undefined
        * boolean
        * number
        * string
        * object
        * symbol
    * object를 제외한 이들을 '원시 타입'이라 한다.
    * 값 타입은 typeof로 알 수 있다.    
        * 그러나 typeof null === "object" 이다.
            * 그래서 null 값을 정확히 확인하려면 조건이 하나 더 필요하다
            ```
            (!a && typeof === 'object')
            ```
            * null은 falsy한 유일한 원시값이지만, 타입은 'object'인 특별한 존재다.
    * typeof가 반환하는 문자열은 하나 더 있다.
        * typeof function a(){ } === 'function'
        * typeof 반환 값을 보면 마치 function이 최상위 레벨의 내장 타입처럼 보이지만 명세를 읽어보면 실제로는 object의 하위 타입이다.
        * 구체적으로 설명하면 함수는 '호출 가능한 객체' 라고 명시되어 있다.
            * 내부 프로퍼티 [[Call]] 로 호출할 수 있는 객체.
        * 사실 함수는 객체라서 유용하다.
        * 무엇보다 함수에 프로퍼티를 둘 수 있다.
        ```
        function a (b, c) {
        }
        a.length // 2
        ```
        * 함수에 선언된 인자의 개수는 함수 객체의 length 프로퍼티로 알 수 있다.
    * 배열도 그냥 객체이다.
        * typeof [1, 2, 3] === 'object'
        * 배열은 키가 문자열인 객체와 반대로 숫자 인덱스를 가지며, length 프로퍼티가 자동으로 관리되는 등의 추가 특성을 지닌, 객체의 하위 타입이라 할 수 있다.

* 값은 타입을 가진다.
    * 값에는 타입이 있지만, 변수엔 따로 타입이란 없다.
    * 변수는 언제라도, 어떤 형태의 값이라도 가질 수 있다.
    * 자바스크립트는 type enforcement를 하지 않는다.
    * 변숫값이 처음에 할당된 값과 동일한 타입일 필요는 없다.

* 값이 없는 vs 선언되지 않은
    * 값이 없는 변수의 값은 undefined이며, typeof 결과는 'undefined'이다.
    * '값이 없는'과 '선언되지 않은'은 다른 개념이다.
        ```
        var a;
        a // undefined
        b // ReferenceError: b가 정의되지 않았습니다.

        typeof a; // 'undefined'
        typeof b; // 'undefined'
        ```
        * __선언되지 않은 변수도 typeof 하면 undefined로 나온다.__
        * 바로 이것이 typeof만의 독특한 safety guard다.
* 선언되지 않은 변수
    * 브라우저에서 자바스크립트 코드를 처리할 떄, 특히 여러 스크립트 파일의 변수들이 전역 네임스페이스를 공유할 떄, typeof의 안전 가드는 의외로 쓸모있다.
        * 간단한 예로 프로그램의 디버그 모드를 DEBUG 라는 전역 변수로 조정한다고 치자.
        * 콘솔 창에 메시지 로깅 등 디버깅 작업을 수행하기 전, 이 변수이 선언 여부를 체크해야 할 것이다.
        * 최상위 전역 스코프에 var DEBUG = true 라고 'debug.js' 파일에만 선언하고, 개발/테스트 단계에서 이 파일을 브라우저가 로딩하기만 하면 될 것이다.
        * 그러나 나머지 애플리케이션 코드에서 ReferenceError가 나지 않게 하려면 조심해서 DEBUG 전역 변수를 체크해야 한다.
        ```
        // error
        if(DEBUG){
            console.log('debug start')
        }

        // correct
        if(typeof DEBUG !== 'undefined'){
            console.log('debug start)
        }
        ```
        * 임의로 정의한 변수를 쓰지 않더라도 이런 식으로 체크하는 것이 편리하다.
    * typeof safety guard 없이 전역 변수를 체크하는 다른 방법은 전역 변수가 모두 전역 객체의 프로퍼티라는 점을 이용하는 것이다.
    * 그래서 다음과 같이 체크할 수 있다.
        ```
        if(window.DEBUG){}
        if(!window.DEBUG){}
        ```
        * 선언되지 않은 변수 때와는 달리 어떤 객체의 프로퍼티를 접근할 떄 그 프로퍼티가 존재하지 않아도 ReferenceError가 나지는 않는다.
        * 하지만 window 객체를 통한 전역 변수 참조는 가급적 삼가는 것이 좋다.
        * 전역 변수를 꼭 window 객체로만 호출하지 않는 다중 자바스크립트 환경(브라우저 뿐만 아니라 서버에서 실행되는 node.js 같은...) 이라면 더욱 그렇다.
        * 엄밀히 말해서 typeof 안전 가드는 전역 변수를 사용하지 않을 떄에도 유용한데, 일부 개발자들은 이런 설계 방식이 그다지 바람직하지 않다고 말한다.
        * 이를테면 다른 개발자가 여러분이 작성한 유틸리티 함수를 자신의 모듈/프로그램에 카피 앤 페이스트하여 사용하는데, 가져다 쓰는 프로그램에 유틸리티의 특정 변숫값이 정의되어 있는지 체크해야 하는 상황을 가정해보자.
            ```
            function a(){
                var helper =
                    (typeof b !== undefined) ?
                    b :
                    function(){ // b 기능 };
                var val = helper();
                //
            }
            ```
            * a 함수는 b 변수가 있으면 그대로 사용하고 없으면 함수 바디를 정의한다.
            * 이렇게 해야 다른 사람이 복붙을 해도 안전하게 b 존재하는지를 체크할 수 있다.
            ```
            (function(){
                function b(){ // b 기능 }

                function a(){
                    var helper = 
                        (typeof b !== 'undefined') ?
                        b :
                        function(){ // b기능 }
                    var val = helper();
                    //
                }

                a()
            })
            ```
            * b는 전역 변수는 아니지만, typeof 안전 가드를 이용하여 안전하게 체크하고 있다.
            * 그리고 이 코드에선 체크 용도로 사용할 만한 객체가 없기 때문에 typeof가 꽤 요긴하다.
            * Dependency Injection (의존성 주입) 설계 패턴을 선호하는 개발자들도 있다.
                * b가 a의 바깥이나 언저리에 정의되었는지 암시적으로 조사하는 대신, 다음 코드처럼 명시적으로 의존 관계를 전달하는 것이다.
                ```
                function a(b){
                    var helper = b || function(){ // b 기능 }
                    var val = helper();
                    //
                }
                ```
            * 다양한 설계 옵션이 가능하지만 접근 방식에 따라 장단점이 고루 있어서 어떤 것이 완전히 '맞다', '틀리다' 라고 할 수는 없다.
            * 하지만 대체로 typeof safety guard가 선택할 수 있는 옵션이 많아서 좋다.
* 정리하기
    * 자바스크립트에는 7가지 내장 타입이 있다.
    * typeof 연산자로 타입명을 알아낼 수 있다.
    * 변수는 타입이 없지만 값은 타입이 있고, 타입은 값의 내재된 특성을 정의한다.
    * undefined와 undeclared는 다르다.
    * typeof safety guard를 사용하여 선언되지 않은 변수에 사용하여 예방을 할 수 있다.

## 값
* 배열
    * 자바스크립트 배열은 타입이 엄격한 다른 언어와 달리 문자열, 숫자, 객체 심지어 다른 배열이나 어떤 타입의 값이라도 담을 수 있는 그릇이다.
    * 배열 크기는 미리 정하지 않고도 선언할 수 있으며 원하는 값을 추가하면 된다.
    * 배열 자체도 하나의 객체여서 키/프로퍼티 문자열을 추가할 수 있다.
    * 하지만 length는 증가하지 않는다.
    * 그런데 키로 넣은 문자열 값이 표준 10진수 숫자로 타입이 바뀌면, 마치 문자열 키가 아닌 숫자 키를 사용한 것 같은 결과가 초래된다.
    * 하지만 이런 짓은 하지 말자.
* 유사 배열
    * 유사 배열 값을 진짜 배열로 바꾸고 싶을 떄가 더러 있다.
    * 이럴 때는 배열 유틸리티 함수를 사용하여 해결하는 것이 일반적이다.
    * 예를 들어 DOM 쿼리 작업을 수행하면 비록 배열은 아니지만 변환 용도로는 충분한, 유사 배열 형태의 DOM 원소 리스트가 반환된다.
    * 다른 예로, 함수에서 arguments 객체를 사용하여 인자를 리스트로 가져오는 것(ES6부터 비 권장)도 마찬가지다.
    * 이런 변환은 slice() 함수의 기능을 차용하는 방법을 가장 많이 쓴다.
    ```
    function foo(){
        var arr = Array.prototype.slice.call(arguments);
        return arr;
    }
    foo('a','b') // ['a','b']
    ```
    * ES6 부터는 기본 내장 함수 Array.from() 이 이 일을 대신한다.
    ```
    var arr = Array.from(arguments);
    ```

* 문자열
    * 흔히 문자열은 단지 문자의 배열이라고 생각한다.
    * 엔진 내부적으로 배열을 쓰도록 구현되었는지는 모르겠지만 자바스크립트는 문자열은 실제로 생김새만 비슷할 뿐 문자 배열과 같지 않다는 사실을 알아야 한다.
    ```
    var a = 'foo'
    var b = ['f','o','o']
    ```
    * 문자열은 배열과 겉모습이 닮았다. (유사 배열이다.)
    * 이를테면 둘 다 length 프로퍼티, indexOf() 메서드, concat() 메서드를 가진다.
    * 하지만 차이점이 있다.
        * 문자열은 Immutable(불변 값) 이지만 배열은 Mutable(가변 값)이다.
        ```
        a[1] ='0'
        b[1] ='0'
        a; // 'foo'
        b; // ['f','0','o']
        ```
        * 또한 문자열은 불변 값이므로 문자열 메서드는 그 내용을 바로 변경하지 않고 항상 새로운 문자열을 생성한 후 반환한다.
        * 반면에 대부분의 배열 메서드는 그 자리에서 곧바로 원소를 수정한다.
        ```
        c = a.toUpperCase()
        a; 'foo'
        c; 'FOO'
        ```
        * 그리고 문자열을 다룰 떄 유용한 대부분의 배열 메서드는 사실상 문자열에 쓸 수 없지만, 문자열에 대해 불변 배열 메서드를 빌려 쓸 수는 있다.
        ```
        a.join // undefined
        a.map // undefined
        var c = Array.prototype.join.call(a, '-')
        var d = Array.prototype.map.call(a, function(v){
            return v.toUpperCase()+'.';
        }).join('');
        c; // 'f-o-o'
        d; // 'F.O.O'
        ```
        * 다음은 문자열의 순서를 거꾸로 뒤집는 코드다.
        * 배열에는 reverse()라는 가변 메서드가 준비되어 있지만, 문자열은 그렇지 않다.
        * 불행히도 문자열은 불변 값이라 바로 변경되지 않으므로 배열의 가변 메서드는 통하지 않고, 그래서 빌려 쓰는 것 또한 안 된다.
        * 일단 문자열을 배열로 바꾸고 원하는 작업을 수행한 후 다시 문자열로 되돌리는 것이 또다른 hack(꼼수)이다.
        ```
        var c = a.split('').reverse().join('');
        c; // 'oof'
        ```
        * 하지만 복잡한 문자가 섞여있는 경우, 이 방법은 통하지 않는다.
        * 문자열 자체에 어떤 작업을 빈번하게 수행하는 경우라면 관점을 달리하여 문자열을 문자 단위로 저장하는 배열로 취급하는 것이 더 나을 수도 있다.
* 숫자
    * 자바스크립트의 숫자 타입은 number가 유일하다.
    * 정수, 부동 소수점 숫자를 모두 아우른다.
    * 진정한 정수는 사실 없다.
    * 정수는 부동 소수점 값이 없는 값이다. (42.0 -> 42)
    * 사실상 모든 스크립트 언어를 통틀어 대부분의 현대 프로그래밍 언어는 'IEEE 753' 표준을 따른다.
    * 그중에서도 정확히는 Dobule Precision(배 정도) 표준 포맷(64비트 바이너리)를 사용한다.
    * 숫자 값은 Number 객체 wrapper로 boxing 할 수 있기 때문에 Number.prototype 메서드로 접근할 수도 있다.
    * 예를 들면 toFixed() 메서드는 지정한 소수점 이하 자릿수까지 숫자를 나타낸다.
    ```
    var a = 42.59
    a.toFixed(0) // 43
    a.toFixed(1) // 42.6
    a.toFixed(2) // 42.59
    a.toFixed(3) // 42.590
    ```
    * 실제로는 숫자 값을 문자열 형태로 반환하며, 원래 값의 소수점 이하 숫자보다 더 많은 자릿수를 지정하면 그만큼 0이 우측에 붙는다.
    * 이러한 메서드는 숫자 리터럴에서 바로 접근할 수 있으므로 굳이 변수를 만들어 할당하지 않아도 된다.
    * 하지만 .이 소수점일 경우엔 프로퍼티 접근자가 아닌 숫자 리터럴의 일부로 해석되므로 . 연산자를 사용할 떄는 조심하자.
    ```
    42.toFixed(3); //SyntaxError

    (42).toFixed(3);
    0.42.toFixed(3);
    42..toFixed(3);
    ```
* 작은 소수 값
    * 다음은 널리 알려진 이진 부동 소수점 숫자의 부작용이다.
    ```
    0.1 = 0.2 === 0.3; // false
    ```
    * 간단히 말하면, 이진 부동 소수점으로 나타낸 0.1과 0.2는 원래의 숫자와 일치하지 않는다.
    * 그래서 둘을 더한 결과 역시 정확히 0.3이 아니다.
    * 실제로는 0.300000000000000004 에 가깝지만, '가깝다고' 해도 '같은' 것은 아니다.
        * 가장 일반적인 해결책은 미세한 '반올림 오차' 를 허용 공차로 처리하는 방법이 있다.
        * 이렇게 미세한 오차를 Machine Eplsilon 이라고 한다.
        * 자바스크립트의 입실론은 2^-52 이다. (2.220446.......)
    * ES6부터는 이 값이 Number.EPSILON 으로 미리 정의되어 있으므로 필요시 사용하면 된다.
    ```
    function numbersCloseEnoughToEqual(n1, n2){
        return Math.abs(n1 -n2) < Number.EPSILON;
    }
    var a = 0.1+0.2
    var b = 0.3
    numbersCloseEnoughToEqual(a, b)
    ```    
    * 일반적으로는 정수만을 다루니 큰 문제는 없다.
* 안전한 정수 범위
    * 안전하게 표현할 수 있는 정수는 최대 2^53-1 (9007199254740991) 이다. (9천 조)
    * 이 값은 ES6에서 Number.MAX_SAFE_INTEGER로 정의한다.
    * 자바스크립트 프로그램에서 이처럼 아주 큰 숫자에 맞닥뜨리는 경우는 데이터베이스 등에서 64비트 ID를 처리할 때가 대부분이다.
    * 64비트 숫자는 숫자 타입으로 정확하게 표시할 수 없으므로 자바스크립트 string 타입으로 저장해야 한다.
* 정수인지 확인
    * ES6부터는 Number.isInteger()로 어떤 값의 정수 여부를 확인한다.
    ```
    if(!Number.isInteger){
        Number.isInteger = function(num){
            return typeof num == "number" && num % 1 == 0;
        }
    }
    ```
* 32비트 (부호 있는) 정수
    * 정수의 안전 범위에 비해 32비트 숫자에만 가능한 연산이 있으므로 실제 범위는 훨씬 줄어든다.
    * 따라서 정수의 안전 범위는 Math.pow(-2,31) 에서 Math.pow(2,31)-1  까지다.
* 특수 값
    * 값 아닌 값
        * Undefined 타입의 값은 undefined밖에 없다.
        * null 타입도 값은 null 뿐이다.
        * 그래서 이 둘은 타입과 값이 항상 같다.
        * undefined와 null은 종종 empty 값과 nonvalue 값을 나타낸다.
        * null은 식별자가 아닌 키워드이므로 변수에 뭔가 할당할 수는 없다.
        * 그런데 undefined는 식별자로 쓸 수 있다.
        ```
        function foo(){
            undefined = 2 // 미친 짓 
        }
        foo();
        function foo(){
            use strict;
            undefined = 2; // error
        }
        foo();
        ```
        * 모드에 상관없이 undefined란 이름을 가진 지역 변수는 생성할 수 있다.
        * 하지만 하지마...
    * void 연산자
        * undefined는 내장 식별자로 값은 undefined지만, 이 값은 void 연산자로도 얻을 수 있다.
        * 표현식 void _ _ 는 어떤 값이든 '무효로 만들어', 항상 결괏값을 undefined로 만든다.
        * 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.
        ```
        var a = 42;
        console.log(void a, a) // undefined, 42
        ``` 
        * 관례에 따라 void 만으로 undefined 값을 나타내려면 void 0 이라고 쓴다.
        * void 0, void 1, undefined 모두 같다.
        * void 연산자는 어떤 표현식의 결괏값이 없다는 걸 확실히 밝혀야 할 때 요긴하다.
        ```
        function a(){
            if(!APP.ready){
                return void setTimeout(a,100);
            }
            var result;
            // 별도 처리 수행
            return result;
        }
        if(a()){
            // 다음 작업 바로 실행
        }
        ```
        * setTimeout() 함수는 숫자 값(타이머를 취소할 때 사용할 고유 식별자)을 반환하지만, 예제에서는 이 숫자 값을 무효로 만들어 a() 함수의 결괏값이 if 문에서 긍정 오류가 일어나지 않게 했다.
        * 이때 다음 코드처럼 두 줄로 분리해 쓰는 걸 선호하는 개발자들이 많고 void 연산자는 잘 쓰지 않는다.
        ```
        if(!APP.ready){
            setTimeout(a,100);
            return;
        }
        ```
        * 정리하면 void 연산자는 값이 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에만 사용하자.
        * 아마도 그렇게 해야 할 경우도 거의 없고 극히 제한적으로 쓰이겠지만 제법 쓸모는 있다.

* 특수 숫자
    * 숫자 타입에는 몇가지 특수한 값이 있다.
    * The not number, number
    * 수학 연산 시 두 피연산자가 전부 숫자가 아닐 경우 유효한 숫자가 나올 수 없으므로 그 결과는 NaN 이다.
    * NaN은 글자 그대로 숫자 아님이다.
    * 그런데 이 명칭과 설명이 아주 형편없고 오해의 소지가 다분하다.
    * NaN은 숫자 아님 보다는 유효하지 않은 숫자, 실패한 숫자, 또는 몹쓸 숫자라고 하는게 차라리 더 정확하다.
    ```
    var a = 2 / 'foo'; // NaN
    typeof a === 'number' // true
    ```
    * 즉, '숫자 아님의 typeof는 숫자다'
    * 어떤 변숫값이 특수한 실패 숫자, 즉 NaN 인지 여부를 확인할 떄 null, undefined처럼 NaN도 직접 비교하고 싶은 충동이 생기겠지만, 그러면 안된다.
    ```
    var a = 2 / 'foo'
    a == NaN // false
    a === NaN // false
    ```
    * NaN은 어떤 NaN과도 동등하지 않다.
    * 자기 자신과도 같지 않다.
    * 사실상 반사성이 없는 유일무이한 값이다.
    ```
    var a = 2 / 'foo'  
    isNaN(a) // true
    ```
    * 내장 전역 유틸리티 isNaN() 함수가 NaN 여부를 말해준다.
    * 그러나 isNaN() 에는 치명적인 결함이 있다.
    * 이 함수는 NaN('숫자 아님')의 의미를 너무 글자 그대로만 해석해서 실제로 '인자 값이 숫자인지 여를 평가'하는 기능이 전부다.
    * 하지만 이래서는 결과가 정확할 수 없다.
    ```
    var a = 2 / 'foo'
    var b = 'foo'
    a; // NaN
    b; // 'foo'
    window.isNaN(a) // true
    window.isNaN(b) // true
    ```
    * foo 는 당연히 숫자가 아니지만, 그렇다고 NaN은 아니다.
    * 이 버그는 자바스크립트 탄생 이후 오늘까지 계속 됐다.
    * ES6 부터는 해결사 Number.isNaN()이 등장한다.
    ```
    if(!Number.isNaN){
        Number.isNaN = function(n){
            return(
                typeof n === 'number' &&
                window.isNaN(n)
            )
        }
    }
    var a = 2 / 'foo'
    var b = 'foo'

    Number.isNaN(a) // true
    Number.isNaN(b) // false
    ```
    * NaN이 자기 자신과도 동등하지 않는 독틈함을 응용하여 폴리필을 더 간단하게 구현할 수도 있다.
    ```
    if(!Number.isNaN){
        Number.isNaN = function(n){
            return n!==n
        }
    }
    ```    
    * 되게 이상해 보이지만 잘 작동한다.
    * 실제로 많은 자바스크립트 코드에 NaN은 고의/실수로 박혀있다.
    * 의미를 오해하지 않고 바르게 쓰려면 Number.isNaN() 같은 내장 유틸리티를 사용하자.
* 무한대
    * 자바스크립트는 0으로 나누기 연산이 잘 정의되어 있다.
    ```
    var a = 1 / 0; // Infinity
    var b = -1 /0; // -Infinity
    ```
* 0
    * 음의 영은 표기만 -0으로 하는 것이 아니다.
    * 특정 수식의 연산 결과 또한 -0으로 떨어진다.
    * -0이 필요한 이유는 어떤 변숫값이 0에 도달하여 부호가 바뀌는 순간, 그 직전까지 이 변수의 이동 방향을 알기 위해 필요하다.
    * 즉, 잠재적인 정보 소실을 방지하기 위해 0의 부호를 보존한 셈이다.
* 특이한 동등 비교
    * ES6부터는 잡다한 예외를 걱정하지 않아도 두 값이 절대적으로 동등한지를 확인하는 새로운 유틸리티를 지원한다.
        * Object.is(a, b)
        ```
        var a = 2 / 'foo';
        var b = -3 * 0;

        Object.is(a, NaN) // true
        Object.is(b, -0) // true
        Object.is(b, 0) // false
        ```
* 값 vs 레퍼런스
    * 자바스크립트는 포인터라는 개념 자체가 없고 참조하는 방법도 조금 다르다.
    * 우선 어떤 변수가 다른 변수를 참조할 수 없다.
    * 자바스크립트에서 레퍼런스는 값을 가리키므로 서로 다른 10개의 레퍼런스가 있다면 이들은 저마다 항상 공유된 단일 값을 개별적으로 참조한다.
    * 서로에 대한 레퍼런스/포인터 따위는 없다.
    * 더구나 자바스크립트에는 값 또는 레퍼런스의 할당 및 전달을 제어하는 구문 암시(Syntactic Hint)가 전혀 없다.
    * 대신, 값의 타입만으로 값-복사, 레퍼런스-복사 둘 중 한쪽이 결정된다.
    ```
    var a = 2;
    var b = a; // 'b'는 언제나 'a'에서 값을 복사한다.
    b++;
    a; // 2
    b // 3

    var c = [1, 2, 3];
    var d = c; // 'd'는 공유된 '[1, 2, 3]'값의 레퍼런스다.
    d.push(4);
    c; // [1, 2, 3, 4]
    d; // [1, 2, 3, 4]
    ```
    * null, undefined, string, number, boolean, symbol 같은 단순 값(scalar primitives)은 언제나 값-복사 방식으로 할당/전달된다.
    * 객체나 함수 등 합성 값(computed values)은 할당/전달시 반드시 레퍼런스 사본을 생성한다.
    ```
    function foo(x){
        x.push(4)
        x; [1,2,3,4]

        x = [4,5,6]
        x.push(7)
        x; [4,5,6,7]
    }
    var a = [1,2,3]
    foo(a)
    a; // [4,5,6,7] 이 아닌 [1,2,3,4]
    ```
    * a를 인자로 넘기면 a의 레퍼런스 사본이 x에 할당된다.
    * x와 a는 모두 동일한 [1,2,3] 값을 가리키는 별도의 레퍼런스다.
    * 합성 값을 값-복사에 의해 효과적으로 전달하려면 손수 값의 사본을 만들어 전달한 레퍼런스가 원본을 가리키지 않게 하면 된다.
    ```
    foo(a.slice());
    ```
    * 인자 없이 slice()를 호출하면 전혀 새로운 배열의 사본을 만든다.
* 정리하기
    * 자바스크립트 배열은 모든 타입의 값들을 숫자로 인덱싱한 집합이다.
    * 문자열은 일종의 유사 배열이지만, 나름 특성이 있기 때문에 배열로 다루고자 할 때에는 조심하는 것이 좋다.
    * 자바스크립트 숫자는 정수와 부동 소수점 숫자 모두 포함한다.
    * 원시 타입에는 몇몇 특수 값이 있다.
    * null 타입은 null 이란 값 하나 뿐이다.
    * undefined타입도 값은 undefined 하나 뿐이다.
    * undefined는 할당된 값이 없다면 모든 변수/프로퍼티의 디폴트 값이다.
    * void 연산자는 어떤 값이라도 undefined로 만들어 버린다.
    * 숫자에는 NaN(설명은 '숫자 아님' 이지만, 사실 '유효하지 않은 숫자' 라고 해야 더 정확하다.), Infinity, -Infinity, -0 같은 특수 값이 있다.
    * 단순 스칼라 원시 값은 값-복사에 의해, 합성 값은 레퍼런스-복사에 의해 값이 할당/전달된다.
    * 자바스크립트에서의 레퍼런스는 다른 언어의 레퍼런스/포인트와는 전혀 다른 개념으로, 또 다른 변수/레퍼런스가 아닌 오직 자신의 값만을 가리킨다.

## 네이티브
* 네이티브란 말은 자바스크립트 계에서 여기저기 남용되고 있다.
    * 영어 단어의 의미를 상기하여 기본적인 정의를 내린다면, 네이티브란 특정 환경에 종속되지 않은, ECMAScript 명세의 내장 객체를 말한다.
    * 예를 들어 Object, Math, Function, Array, Window, Button 중 네이티브가 아닌 것은 Window와 Button 이다.

* 자주 쓰이는 네이티브
    * String()
    * Number()
    * Boolean()
    * Array()
    * Object()
    * Function()
    * RegExp()
    * Date()
    * Error()
    * Symbol()
    * 네이티브는 사실 내장 함수이다.

* 네이티브는 생성자처럼 사용할 수 있지만 실제로 생성되는 결과물은 예상과는 다를 수 있다.
    ```
    var a = new String('abc');
    typeof a // 'object' (String이 아니다)
    a instanceof String // true
    Object.prototype.toString.call(a) // '[object String]'
    ```
    * new String('abc') 생성자의 결과는 원시 값 'abc'를 감싼 객체 래퍼다.
    * 놀랍게도 typeof 연산자로 이 객체의 타입을 확인해보면 자신이 감싼 원시 값의 타입이 아닌 object의 하위 타입에 가깝다.
    * 객체 래퍼가 어떻게 생겼는지 들여다 보자.
    ```
    console.log(a);
    ```
    * 이 코드의 실행 결과는 브라우저마다 다르다.
    * 개발자 콘솔 창에 어떻게 객체를 직렬화하여 보여주는 편이 좋을지는 브라우저 개발자가 임의로 결정했기 때문이다.
        * 최신 크롬: String{0: 'a', 1: 'b', 2: 'c', length: 3, [[primitiveValue]]: 'abc' }
        * 구 크롬: String{0: 'a', 1: 'b', 2: 'c'}
        * 파이어폭스: String ['a','b','c']
    * 요지는 new String('abc')는 'abc'를 감싸는 문자열 래퍼를 생성하며 원시 값 'abc'는 아니라는 점이다.

* 내부 [[Class]]
    * typeof 가 'object'인 값(배열 등)에는 [[Class]] 라는 내부 프로퍼티가 추가로 붙는다.
        * 전통적인 클래스 지향의 개념에서의 클래스가 아니다.
        * 내부 분류법(classification)의 일부라고 보는 것이 맞다.
    * 이 프로퍼티는 직접 접근할 수 없고 Object.prototype.toString() 라는 메서드에 값을 넣어 호출함으로써 존재를 엿볼 수 있다.
    ```
    Object.prototype.toString.call([1,2,3])
    // "[object Array]"

    Object.prototype.toString.call(/regex-literal/i);
    // "[object RegExp]"
    ```
    * 내부 [[Class]] 값이, 배열은 Array, 정규식은 RegExp 임을 알 수 있다.
    * 대부분 내부 [[Class]]는 해당 값과 관련된 내장 네이티브 생성자를 가리키지만, 그렇지 않을 때도 있다.
    * 원시 값에도 내부 [[Class]]가 있을까?
    ```
    Object.prototype.toString.call(null)
    // "[object Null]"
    Object.prototype.toString.call(undefined)
    // "[object Undefined]"
    ```
    * Null(), Undefined() 같은 네이티브 생성자는 없지만 내부 [[Class]]값을 확인해보니 "Null", "Undefined"이다.
    * 하지만 그 밖에 문자열, 숫자, 불리언 같은 단순 원시 값은 이른바 'Boxing' 과정을 거친다.
    ```
    Object.prototype.toString.call('abc')
    // "[object String]"
    Object.prototype.toString.call(42)
    // "[object Number]"
    Object.prototype.toString.call(true)
    // "[object Boolean]"
    ```
    * 내부 값이 각각 Strign, Number, Boolean으로 표시된 것으로 보아 단순 원시 값은 해당 객체 래퍼로 자동 박싱됨을 알 수 있다.
* 래퍼 박싱하기
    * 객체 래퍼는 아주 중요한 용도로 쓰인다.
    * 원시 값엔 프로퍼티나 메서드가 없으므로 .length, .toString() 으로 접근하려면 원시 값을 객체 래퍼로 감싸줘야 한다.
    * 고맙게도 자바스크립트는 원시 값을 알아서 박싱하므로 다음과 같은 코드가 가능하다.
    ```
    var a = 'abc'
    a.length
    a.toUpperCase();
    ```
    * 따라서 루프 조건 i < a.length 처럼 빈번하게 문자열 값의 프로퍼티/메서드를 사용해야 한다면 자바스크립트 엔진이 암시적으로 객체를 생성할 필요가 없도록 처음부터 값을 객체로 갖고 있는 것이 이치에 맞는 것처럼 보인다.
    * 하지만 좋은 생각이 아니다.
    * 오래전부터 브라우저는 이런 흔한 경우를 스스로 최적화하기 때문이다.
    * 즉, 개발자가 직접 객체 형태로 선 최적화하면 프로그램이 더 느려질 수 있다.
    * 직접 객체 형태로 써야 할 이유는 거의 없다.
    * 필요시 엔진이 알아서 암시적으로 박싱하게 하는 것이 낫다.
    * 즉, new String('abc') 처럼 코딩하지 말고 그냥 알기 쉽게 원시값 'abc'를 사용하자
* 언박싱
    * 객체 래퍼의 원시 값은 valueOf() 메서드로 추출한다.
* 네이티브, 나는 생성자다.
    * 배열, 객체, 함수, 정규식 값은 리터럴 형태로 생성하는 것이 일반적이지만, 리터럴은 생성자 형식으로 만든 것과 동일한 종류의 객체를 생성한다.
    * 즉, 래핑되지 않은 값은 없다.
    * 앞에서 살펴본 다른 네이티브도 그랬듯이, 확실히 필요해서 쓰는 게 아니라면 생성자는 가급적 쓰지 않는 편이 좋다.
    * 나중에 별별 오류와 함정에 빠져 고생하고 싶지 않으면 말이다.
* Date() and Error()
    * 네이티브 생성자 Date()와 Error()는 리터럴 형식이 없으므로 다른 네이티브에 비해 유용하다.
    * Date
        * date 객체 값은 new Date()로 생성한다.
        * 이 생성자는 날짜/시각을 인자로 받는다.
        * date 객체는 유닉스 타임스탬프 값(1970년 1월 1일부터 현재까지 흐른 시간을 초 단위로 환산)을 얻는 용도로 가장 많이 쓰일 것이다.
        * date 객체의 인스턴스로부터 getTime()을 호출하면 된다.
        * new 키워드 없이 Date()를 호출하면 현재 날짜/시각에 해당하는 문자열을 반환한다.
    * Error
        * 앞에 new가 있든 없든 결과는 같다.
        * error 객체의 주 용도는 현재의 실행 스택 콘텍스트를 포착하여 객체(자바스크립트 엔진 대부분이 읽기 전용 프로퍼티인 .stack에 접근 가능하다.)에 담는 것이다.
        * 이 실행 스택 콘텍스트는 함수 호출 스택, error 객체가 만들어진 줄 번호 등 디버깅에 도움이 될 만한 정보들을 담고 있다.
        * error 객체는 보통 throw 연산자와 함께 사용한다.
        ```
        function foo(x){
            if(!x){
                throw new Error(' x i falsy ')
            }
        }
        ```
        * Error 객체 인스턴스에는 적어도 message 프로퍼티는 들어 있고, type 등 다른 프로퍼티가 포함되어 있을 때도 있다.
        * 그러나 사람이 읽기 편한 포맷으로 에러 메시지를 보려면 방금 전 언급한 stack 프로퍼티 대신, 그냥 error 객체의 toString()을 호출하는 것이 좋다.
            * 굳이 따진다면 일반적인 Error() 네이티브 이외에도 에러 타입에 특화된 네이티브들이 있다.
            * RefernceError(), SyntaxError(), TypeError(), ...
            * 네이티브들은 코드에서 실제로 예외가 발생하면 자동으로 던져지므로 직접 사용할 일은 거의 없다.
* Symbol()
    * 심볼은 충돌 염려 없이 객체 프로퍼티로 사용 가능한, 특별한 '유일 값' 이다.
    * 절대적으로 유일함이 보장되지 않는다...?
    * 주로 ES6의 특수한 내장 로직에 쓰기 위해 고안되었지만 사용자도 얼마든지 심볼을 정의할 수 있다.
    * 심볼은 프로퍼티명으로 사용할 수 있으나, 프로그램 코드나 개발자 콘솔 창에서 심볼의 실제 값을 보거나 접근하는 건 불가능하다.
    * 심벌 값을 콘솔 창에 출력해보면 Symbol(Symbol.create)로 나온다.
    * ES6에는 심볼 몇 개가 미리 정의되어 있는데 Symbol.create, Symbol.iterator 식으로 Symbol 함수 객체의 정적 프로퍼티로 접근한다.
    ```
    obj[Symbol.iterator] = function(){ // }
    ```
    * 심볼을 직접 정의하려면 Symbol() 네이티브를 사용한다.
    * Symbol() 은 앞에 new를 붙이면 에러가 나는, 유일한 네이티브 생성자다.
    * 심볼은 private 프로퍼티는 아니지만 본래의 사용 목적에 맞게 대부분 전용 혹은 특별한 프로퍼티를 사용한다.
    * 관습적으로 private임을 알리기 위해 써왔던 언더스코어(_)가 앞에 붙은 프로퍼티 명도 언젠가는 심볼에 의해 완전히 대체될 가능성이 높다.
    * 심볼은 객체가 아니다.
    * 단순한 스칼라 원시 값이다.
* 네이티브 프로토타입
    * 내장 네이티브 생성자는 각자의 .prototype 객체를 가진다.
        * prototype 객체에는 해당 객체의 하위 타입별로 고유한 로직이 담겨 있다.
    * 이를 테면 문자열 원시 값을 확장한 것까지 포함하여 모든 String 객체는 기본적으로 String.prototype 객체에 정의된 메서드에 접근할 수 있다.
        * 문서화 관례에 따라 String.prototype.a 는 String#a로 줄여쓴다.
        * String#indexOf()
            * 문자열에서 특정 문자의 위치를 검색
        * String#charAt()
            * 문자열에서 특정 위치의 문자를 반환
        * String#substr(), String#substirng(), String#slice()
            * 문자열의 일부를 새로운 문자열로 추출
        * String#toUpperCase(), String#toLowerCase()
        * String#trim()
            * 앞/뒤 공란이 제거된 새로운 문자열 생성
    * 이 중 문자열 값을 변경하는 메서드는 없다.
    * 수정이 일어나면 늘 기존 값으로부터 새로운 값을 생성한다.
    * 프로토타입 위임 덕분에 모든 문자열이 이 메서드들을 같이 쓸 수 있다.
* 정리하기
    * 자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브를 제공한다.
    * 객체 래퍼에는 타입별로 쓸 만한 기능이 구현되어 있어 편리하게 사용할 수 있다.
    * 'abc' 같은 단순 스칼라 원시 값이 있을 때, 이 값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 박싱하여 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.
## 강제 변환
* 값 변환
    * 어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적으면 Type Casting(타입 캐스팅), 암시적이면 Coercion(강제 변환) 이라고 한다.
    * 박싱은 강제 변환이 아니다.
    * 두 용어를 이렇게 구분하는 사람들도 있다.
    * Type Casting(또는 Type Conversion)은 정적 타입 언어에서 컴파일 시점에, 강제변환은 동적 타입 언어에서 런타임 시점에 발생한다.
    * 그러나 자바스크립트에서는 대부분 모든 유형의 타입변환을 강제변환으로 뭉뚱그려 일컫는 경향이 있어서, 여기서는 암시적 강제변환과 명시적 강제 변환 두 가지로 구별하겠다.
    * 차이는 명확하다.
    * 명시적 강제변환은 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백한 반면, 암시적 강제변환은 다른 작업 도중 불문명한 부수 효과로부터 발생하는 타입변환이다.
    ```
    var a = 42;
    var b = a + ''; // 암시적 강제변환
    var c = String(a) // 명시적 강제 변환
    ```
    * 엄밀히 말해 스타일의 차이뿐 아니라 작동상에도 미묘한 차이가 있다.
* 추상 연산
    * 명시적/암시적 강제변환의 세계로 떠나기 전에 어떻게 값이 문자열, 숫자, 불리언 등의 타입이 되는지 그 규칙을 알아보자.
    * ES5를 보면 변환 규칙의 '추상 연산'이 정의되어 있다.
    * ToString, ToNumber, ToBoolean, ToPrimitive
        * ToString
            * 문자열이 아닌 값 -> 문자열
            * 내장 원시 값은 본연의 문자열화 방법이 정해져 있다.
                * ex) null -> 'null', undefined -> 'undefined', true -> 'true'
                * 숫자는 문자열로 바뀌고 너무 작거나 큰 값은 지수 형태로 바뀐다.
            * 일반 객체는 특별히 지정하지 않으면 기본적으로 toString() 메서드가 내부 [[Class]]를 반환한다. 
                * ex) "[object Object]"
            * 배열은 기본적으로 재정의된 toString()이 있다.
                * 문자열 변환 시 모든 원소 값이 콤마로 분리된 형태로 이어진다.
            * JSON 문자열화
                * ToString은 JSON.stringfy() 유틸리티를 사용하여 어떤 값을 JSON 문자열로 직렬화 하는 문제와도 연관된다.
                * JSON 문자열화는 강제변환과 똑같지는 않지만, 방금 전 살펴본 ToString 규칙과 관련이 있다.
                * 대부분 단순 값들은 직렬화 결과가 반드시 문자열이라는 점을 제외하고는, JSON 문자열화나 toString() 변환이나 기본적으로 같은 로직이다.
                * JSON 안전 값은 모두 JSON.stringfy()로 문자열화할 수 있다.
                * JSON 안전 값이 아닌 것들을 반대로 떠올리면 이해가 빠를 것이다.
                    * ex) undefined, 함수, 심볼, 환영 참조 객체(프로퍼티 참조가 무한 순환되는 구조의 객체
                    * 이들은 모두 다른 언어로 이식하여 JSON 값으로 쓸 수 없는, 표준 JSON 규격을 벗어난 값이다.
                * JSON.stringfy()는 인자가 undefined, 함수, 심벌 값이면 자동으로 누락시키며 이런 값들이 만약 배열에 포함되어 있으면 null로 바꾼다.
                * 객체 프로퍼티에 있으면 간단히 지워버린다.
                * 환영 참조 객체가 있으면 에러가 난다.
                * JSON.stringfy()는 직접적인 강제변환의 형식은 아니지만 두 가지 이유로 ToString 강제 변환과 연관된다.
                    * 문자열, 숫자, 불리언, NULL 값이 JSON으로 문자열화 하는 방식은 ToString 추상 연산의 규칙에 따라 문자열 값으로 강제변환되는 방식과 동일하다.
                    * JSON.stringfy()에 전달한 객체가 자체 toJSON() 메서드를 갖고 있다면, 문자열화 전 toJSON()가 자동으로 호출되어 JSON 안전 값으로 강제 변환된다.
        * ToNumber
            * 숫자 아닌 값 -> 수식 연산이 가능한 숫자
            * 예를 들어 true는 1, false는 0이 된다.
            * undefined는 NaN, null은 0
            * 문자열 값에 ToNumber를 적용하면 대부분 숫자 리터럴 규칙/구문과 비슷하게 작동한다.
            * 변환이 실패하면 결과는 NaN이다.
            * 한 가지 차이는 0이 앞에 붙은 8진수는 ToNumber에서 올바른 숫자 리터럴이라도 8진수로 처리하지 않는다는 점이다.
                * 대신 일반 10진수로 처리한다.
            * 객체는 일단 동등한 원시 값으로 변환 후 그 결괏값(아직 숫자가 아닌 원시 값)을 앞서 설명한 ToNumber규칙에 의해 강제변환하낟.
            * 동등한 원시 값으로 바꾸기 위해 ToPrimitive 추상 연산 과정에서 해당 객체가 valueOf() 메서드를 구현했는지 확인한다.
            * valueOf()를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환하되, 그렇지 않을 경우 toString() 메서드가 존재하면 toString()을 이용하여 강제변환한다.
            * 어찌해도 원시 값으로 바꿀 수 없을 땐 TypeError 오류를 던진다.
            * ES5 부터는 [[Prototype]]이 null 인 경우 대부분 Object.create(null)을 이용하여 강제변환이 불가능한 객체 (valueOf(), toString() 메서드가 없는 객체)를 생성할 수 있다.
            ```
            var a = {
                valueOf: function(){
                    return '42'
                }
            }
            var b = {
                toString: function(){
                    return '42
                    }
            }
            var c =[4,2];
            c.toString = function(){
                return this.join('')
            }

            Number(a) // 42
            Number(b) // 42
            Number(c) // 42
            Number('') // 0
            Number([]) // 0
            Number(['abc']) // NaN
            ```
        * ToBoolean
            * 우선 자바스크립트에는 true와 false 라는 키워드가 존재한다.
            * 흔히들 1과 0이 각각 true, false에 해당한다고 생각하는데 다른 언어에서는 그럴지 몰라도 자바스크립트에서는 숫자는 숫자고, 불리언은 불리언으로 서로 별개다.
            * 1을 true로 0을 false로 강제변환할 수는 있지만 그렇다고 두 값이 똑같은 건 아니다.
            * Falsy 값
                * true/false가 아닌 값을 불리언에 상당한 값으로 강제변환했을 때, 이 값들은 어떻게 작동할까
                * 자바스크립트의 모든 값은 다음 둘 중 하나다.
                    * 불리언으로 강제변환하면 false가 되는 값
                    * 위를 제외한 나머지(즉, 명백히 true인 값)
                * 불리언으로 강제변환 시 false가 되는 몇 개 안되는 특별한 값들이 자바스크립트 명세에 이미 정의되어 있다.
                    * undefined
                    * null
                    * false
                    * +0, -0, NaN
                    * ""
                * 이게 전부다.
* 명시적 강제변환
    * 문자열 <-> 숫자
        * String()과 Number()를 이용한다.
        * 앞에 new 키워드가 붙지 않기 때문에 객체 래퍼를 생성하는 것이 아니다.
        ```
        var a = 42;
        var b = String(a)
        var c = '3.14'
        var d = Number(c)
        b; // '42'
        d; // 3.14
        ```
        * 앞서 설명했던  ToString 추상 연산 로직에 따라 String()은 값을 받아 원시 문자열로 강제 변환한다.
        * Number() 역시 마찬가지로 ToNumber 추상 연산 로직에 의해 어떤 값이든 원시 숫자 값으로 강제 변환한다.
        ```
        var a = 42;
        var b = a.toString();

        var c = '3.14'
        var d = +c
        
        b; // "42"
        d; // 3.14
        ```
        * a.toString() 호출은 겉보기엔 명시적이지만, 몇 가지 암시적인 요소가 감춰져 있다.
        * 원시 값 42에는 toString() 메서디가 없으므로 엔진은 toString()을 사용할 수 있게 자동으로 42를 객체 래퍼로 '박싱'한다.
        * 말하자면 명시적으로, 암시적인 작동이다.
        * +c의 +는 단한 연산자다.
        * 단항 연산자 +는 덧셈을 하는 게 아니라 피연산자 c 를 숫자로 명시적 강제변환한다.
    * 날짜 -> 숫자
        * +단항 연산자는 'Date -> 숫자' 강제 변환 용도로도 쓰인다.
        ```
        var d = new Date()
        +d; // 1403503513...
        ```
        * 다음과 같이 현재 시각을 타임스탬프로 바꿀 때 관용적으로 사용하는 방법이다.
        ```
        var timestamp = +new Date();
        ```
        * 그러나 강제변환을 하지 않아도 Date 객체로부터 타임스탬프를 얻는 방법이 있다.
        ```
        var timestamp = new Date().getTime();
        ```
        * 하지만 ES5에 추가된 정적 함수 Date.now()를 쓰는 게 더 낫다.
        ```
        var timestamp = new Date().now();
        ```
* 숫자 형태의 문자열 파싱
    ```
    var a = '42'
    var b = '42px'

    Number(a) // 42
    parseInt(a) // 42

    Number(b) // NaN
    parseInt(b) // 42
    ```
    * 문자열로부터 숫자 값의 파싱은 비 숫자형 문자를 허용한다.
    * 즉, 좌->우 방향으로 파싱하다가 숫자 같지 않은 문자를 만나면 즉시 멈춘다.
    * 반면 강제변환은 비 숫자형 문자를 허용하지 않기 때문에 NaN을 반환한다.
    * 파싱은 강제 변환의 대안이 될 수 없다.
    * 비슷해 보여도 목적 자체가 다르다.
    * 우측에 비 숫자형 문자가 있을지 확실하지 않거나 별로 상관없다면 문자열을 숫자로 파싱한다.
    * 반드시 숫자여야만 하고 '42px' 같은 값을 되돌려야 한다면 문자열을 숫자로 강제변환한다.
    * parseInt는 문자열에 쓰는 함수임을 기억하자.
    * ES5 이후의 parseInt()는 제멋대로 해석하지 않는다.
    * 두 번째 인자가 없으면 무조건 10진수로 처리한다.
* 명시적 강제 변환 *->Boolean
    * Boolean()이나 !!을 이용해 true/false 중 하나의 값으로 무조건 바꿀 수 있다.
* 암시적 변환
    ```
    var a ='42'
    var b = '0'

    var c= 42
    var d = 0

    a+b // '420'
    c+d // 42
    a+d // '420'
    ```
    ```
    var a = [1, 2]
    var b = [3, 4]
    
    a+b // '1,23,4'
    ```
    * +알고리즘은 한쪽 피연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다.
    ```
    var a = 42;
    var b = a+''
    b; // '42'
    ```
    * a+'' 는 숫자를 문자열로 암시적 강제변환하는 아주 흔한 관용코드다.
    ```
    var a = '3.14'
    var b = a - 0;
    b; // 3.14
    ```
    * - 연산자는 숫자 뺼셈 기능이 전부이므로 a-0은 a 값을 숫자로 강제변환한다.
    * 자주 쓰이지는 않지만 a*1이나 a/1의 연산자 역시 숫자 연산만 하므로 마찬가지다.
    ```
    var a = [3]
    var b = [1]

    a-b // 2
    ```
    * 두 배열은 우선 문자열로 강제변환한(toString()로 직렬화) 뒤 숫자로 강제 변환된다.
* 암시적 강제변환. 불리언 -> 숫자
    * n개의 인자 중 몇 개가 true인지 함수로 체크하는 방법에 사용될 수 있다.
    ```
    function onlyOne(){
        var sum =0;
        for(var i = 0 ; i < arguments.length i ++){
            // falsy 값은 건너뛴다.
            // 0으로 취급하는 셈이다.
            // 그러나 NaN은 피해야한다.
            if(arguments[i]){
                sum += arguments[i]
            }
        }
        return sum == 1;
    }
    ```
    * true/truthy 를 숫자로 강제변환하면 1이므로 그냥 숫자를 모두 더한 것이 전부이고, sum += arguments[i] 에서 암시적 강제변환이 일어난다.
    ```
    function onlyOne(){
        var sum = 0;
        for(var i = 0; i < arguments.length ; i ++){
            sum += Number(!!argumnets[i])
        }
        return sum === 1;
    }
    ```
    * 명시적 강제변환 버전이다.
* 암시적 강제변환. *->boolean
    * boolean 강제변환이 일어나는 표현식
    * 이런 콘텍스트에서 불리언 아닌 값이 사용되면, 추상 연산 규칙에 따라 일단 불리언 값으로 암시적 강제변환된다.    
        * if() 문의 조건 표현식
        * for( ; ; ) 에서 두 번째 조건 표현식
        * while() 및 do...while() 루프의 조건 표현식
        * ? : 삼항 연산 시 첫 번째 조건 표현식
        * || 및 && 의 좌측 피연산자
            * 이것들은 논리 연산자로 부르는 것 보다 '선택 연산자' 혹은 '피연산자 선택 연산자' 가 더 어울린다.
                * 이유는 자바스크립트에서 이 두 연산자는 다른 언어와 달리 실제로 결괏값이 논리값이 아니기 때문이다.
                * 결괏값은 두 피연산자 중 (오직)한쪽 값이다.
                ```
                var a = 42
                var b = 'abc'
                var c = null

                a || b // 42 
                a && b // 'abc'
                c || b // 'abc'
                c && b // null
                ```
                * C, PHP 같은 언어라면 결괏값은 당연히 true 아니면 false다.
                * 그런데 자바스크립트, 파이썬, 루비 에서는 결괏값이 피연산자 값이다.
                * ||, && 연산자는 우선 첫 번째 피연산자의 불리언 값을 평가한다.
                * 피연산자가 비 불리언 타입이면 먼저 강제변환 후 평가를 계속한다.
                * || 연산자는 그 결과값이 true면 첫 번째 피연산자 값을, false면 두 번째 피연산자 값을 반환한다.
                * && 연산자는 true 면 두 번째 피연산자의 값을, false면 첫 번째 피연산자의 값을 반환한다.
                * ||, && 표현식의 결괏값은 언제나 피연산자의 값 중 하나이고, 평가 결과가 아니다.
                ```
                a || b
                // 대략 다음과 같다.
                a ? a : b

                a && b
                // 대략 다음과 같다.
                a ? b : a
                ```
                * 의미상 차이는 있다.
                * a ? a : b의 a가 만약 복잡한 표현식(이를테면, 함수 호출 등의 부수 효과를 가진 표현식) 이라면, a 표현식은 처음 평가 결과가 truthy 라면 두 번 평가될 가능성이 있다.
                * 반면 a || b 에서 a 는 단 한번만 평가하고 그 결과는 테스트 수행 시 강제변환과 최종 결괏값 양쪽 모두에 사용된다.
                ```
                function foo(a, b){
                    a = a || 'hello'
                    b = b || 'world'
                    console.log(a + " " + b)
                }
                foo(); // hello world
                foo('a', 'b') // 'a b'
                ```
                * a = a|| 'hello' 같은 패턴의 관용 코드는 a 값이 없으면 'hello'를 a 에 디폴트 값으로 할당한다.
                ```
                foo('a','') // 'a wrold'
                ```
                * 두 번쨰 인자 ''는 flasy 값이므로 b에는 default world가 할당된다.
                * || 연산자의 이러한 사용 패턴은 매우 흔하고 제법 쓸 만하지만 falsy 값은 무조건 건너뛸 경우에만 사용해야 한다.
                * 그렇지 않으면 조건 평가식을 삼항 연산자로 더욱 명시적으로 지정해야 한다.
                * 그렇다면 && 는?
                * 자바스크립트 압축기에서 많이 쓰인다.
                * 첫 번째 표현식이 두 번째 표현식의 가드 역할을 하는 가드 연산자 라고 한다.
                ```
                function foo(){
                    console.log(a)
                }
                var a = 42
                a && foo(); // 42
                ```
                * 보통 if(a){foo()} 처럼 작성하는 사람들이 많을 것이다.
                * 하지만 JS 압축기는 코드를 최대한 쥐어짜야 하므로 a && foo() 같이 처리한다.
            * ||, && 연산 결과가 실제로 true/false가 아니라는 사실이 여러분에게 불편할 수도 있다.
            * 지금까지 작성해온 복합 논리 표현식이 포함된 if 문이나 for 루프는 도대체 어떻게 작동했던 것일까?
                * 복합 표현식이 평가된 다음 불리언으로 암시적 강제변환이 일어난것이다.
                ```
                var a = 42;
                var b = null
                var c = 'foo'

                if(a && (b || c)){
                    console.log('true')
                }
                ```
                * (a && (b || c))의 표현식의 실제 결과는 true 가 아닌 'foo' 다.
                * if문은 이 'foo'를 불리언 타입을 강제변환하여 true로 만든다.
* 느슨한/엄격한 동등 비교
    * ==는 강제변환을 허용하지만, ===는 강제변환을 불허한다.
    * ==든, ===든 피연산자의 타입을 체크하는건 매한가지기 떄문에 성능의 차이는 없다.
    * null 및 undefined를 체크하고 싶으면
    ```
    // 가독성 좋고 안전하게 작동하는 암시적 강제 변환
    if(a == null){ // }

    // 명시적으로 체크하지만 흉하고 사소하지만 성능이 약간 떨어진다.
    if( a=== undefined || a === null){ //}
    ```
    * 강제 변환에 상처받지 않을 한 가지 비책은 typeof 연산자다.
        * typeof 연산은 항상 7가지 문자열 중 하나를 반환하므로, 값의 타입을 체크한다고 암시적 강제 변환과 문제가 될 일은 전혀 없다.

* 추상 관계 비고
    * 어느 한쪽이 문자열이 아닐 경우 양쪽 모두 숫자로 강제변환하여 비교한다.
    * 비교 대상이 모두 문자열 값이면, 각 문자를 단순 어휘 비교 한다.
    ```
    var = a ['42']
    var = b = ['043']
    a < b // false
    ```
    * 어휘적인 비교를 할 수 없으면 false
    ```
    var a = { b : 42}
    var b = { b: 43}
    a < b // false
    a == b // false
    a > b // false
    ```
    * a도 [object Object], b도 [object Object]로 변환되어 어휘적인 비교를 할 수 없다.
* 정리하기
    * 강제변환은 많은 욕을 얻어먹는 애물단지지만 알고 보면 많은 경우 꽤 유용한 기능이다.
    * 자바스크립트 개발을 천직으로 생각하는 사람이라면 시간을 내서 강제변환을 꼼꼼히 학습하고 강제변환의 어떤 특성을 적극 활용하고 어떤 부분은 조심해서 우회할지 잘 판단해서 결정해야 한다.
    * 명시적 강제변환은 다른 타입의 값으로 변환하는 의도가 확실한 코드를 말한다.
    * 혼동의 여지를 줄이고 코드 가독성 및 유지보수성을 높일 수 있는 장점이 있다.
    * 암시적인 강제변환은 '숨겨진' 로직에 의한 부수 효과가 있다.
    * 타입변환이 처리되는 과정이 명확하지 않다.
    * 그래서 암시적 강제변환이 명시적 강제변환의 정반대고 나쁜 것이라고들 하지만 실은 암시적 강제변환이 오히려 코드 가독성을 향상하는 장점도 있다.
    * 암시적 강제변환은 변환 과정이 구체적으로 어떻게 일어나는지 명확하게 알고 사용해야 한다.

## 문법
* 문과 표현식
    * statement, expression
    * 두개에는 분명한 차이가 있다.
    ```
    var a = 3 * 6
    a = 42;
    a;
    ``` 
    * 3 * 6은 표현식이다.
    * var a = 3 * 6 두 문은 변수를 선언 하므로 '선언문declaration statement' 이라 한다.
    * a = 42 는 '할당 표현식 assignment expression' 이다.
    * a 는 표현식의 전부지만 이것만으로도 완전한 문이다.
* 객체 분해
    * 분해 할당 Destructuring Assignments
        * 구체적으로는 객체 분해 시 { } 를 사용한다.
        ```
        function getData(){
            return{
                a: 42,
                b:'foo'
            }
        }
        var { a, b } = getData();
        ```
        * {} 를 이용한 객체 분해는 명명된 함수에도 활용할 수 있다.
        * 암시적인 객체 프로퍼티 할당과 비슷한 간편 구문이다.
        ```
        function foo({a, b, c}){
            console.log(a,b,c)
        }
        foo({
            c:[1,2,3],
            a:42,
            b:'foo'
        })
        ```
* else if는 없다.
    * 자바스크립트 문법의 숨겨진 특성이다.
    ```
    if(a) doSomething(a);
    ```
    * 여러 스타일 가이드 문서에는 다음처럼 단일 문 블록도 { } 로 감싸라고 조언한다.
    ```
    if(a) {doSomething(a);}
    ```
    * 그러나 정확히 동일한 문법 규칙이 else 절에도 적용되어 아래의 코드는 실제로는 항상 이렇게 파싱된다.
    ```
    if(a){
        //..
    }
    else if(b){
        // ..
    }
    else{
        // ..
    }

    // 아래처럼 파싱 된다.

    if (a){
        // ...
    }
    else{
        if(b){
            // ...
        }
        else{
            // ...
        }
    }
    ```
    * 즉, else if 라고 쓰는 건 표준 스타일 가이드의 위반 사례가 되며, 단일 if 문과 같이 else를 정의한 셈이 된다.
    * 물론 else if는 이미 누구나 다 쓰는 관용 코드고, 한 단계 하위로 들여쓰기를 하는 효과가 있어 나름 매력은 있다.

* 단락 평가
    * &&, || 연산자는 좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛴다.
    * 그래서 단락('short circuited') 이란 말이 유래된 것이다.
        * 가능한 한 빨리 지름길을 택한다
    * 예를 들어 a && b 에서 a가 falsy면 b는 쳐다보지도 않는다.
    * && 결과가 이미 false로 굳이전 마당에 애써 b를 조사할 필요가 없다.
    * 마찬가지로 a || b 에서 a 가 truthy면, 이미 전체 결괏값은 true로 확정되므로 b는 관심을 두 이유가 없다.
    * 단락 평가는 아주 유용하고 자주 쓰인다.
    ```
    function doSomething(copts){
        if(opts && opts.cool){
            //
        }
    }
    ```
    * opts 는 일종의 가드다.
    * 만약 opts가 존재하지 않는다면 (혹은 객체가 아니라면) 당연히 opts.cool 표현식은 에러일 수밖에 없다.
    * 일단 opts를 먼저 단락 평가 해보고, 그 결과가 실패면 opts.cool은 자동으로 건너뛰니 결과적으로 에러는 나지 않는다.
* 세미콜론 자동 삽입
    * ASI(Automatic Semicolon Insertion)는 자바스크립트 프로그램의 세미콜론이 누락된 곳에 엔진이 자동으로 ; 를 삽입하는 것을 말한다.
    * 단, ASI는 새 줄 에만 적용되며 어떠한 경우에도 줄 중간에 삽입되는 일은 없다.
    * 기본적으로 자바스크립트 파서는 줄 단위로 파싱을 하다가 (; 이 빠져) 에러가 나면 ;을 넣어보고 타당한 것 같으면 ; 를 삽입한다.
        * 즉, 문의 끝 부분과 새 줄/행 바꿈 문자 사이에 공란이나 주석밖에 없으면...
* 에러
    * 자바스크립트에는 하위 에러 타입 (TypeError, ReferenceError, SyntaxError 등) 뿐만 아니라, 일부 에러는 컴파일 시점에 발생하도록 문법적으로 정의되어 있다.
    * 특히 자바스크립트에는 오래 전부터 (컴파일 도중) Early Error(조기 에러)로 붙잡아 던지게 되어 있는, 여러 가지 특정 조건들이 있었다.
    * 코드가 실행도 되기 전에 발생하므로 이런 에러는 try...catch로 잡을 수 없으며, 그냥 프로그램 파싱/컴파일이 실패한다.
        * 너무 이른 변수 사용
            * ES6는 TDZ라는 새로운 개념을 도입했다.
            * TDZ(임시 데드 존)는 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역이다.
            * ES6 let 블록 스코핑이 대표적인 예다.
            ```
            {
                a = 2; // ReferenceError
                let a;
            }
            ```
            * let a 선언에 의해 초기화되기 전 a = 2 할당문이 변수 a에 접근하려고 한다.
            * 하지만 a는 아직 TDZ 내부에 있으므로 에러가 난다.
            * 재밌는 사실은 원래 typeof 연산자는 선언되지 않은 변수 앞에 붙여도 오류는 나지 않는다 TDZ 참조 시에는 이러한 안전장치가 없다.
            ```
            {
                typeof a; // undefined
                typeof b; // ReferenceError
                let b;
            }
            ```
        * 함수 인자
            * TDZ 관련 에러는 ES6 디폴트 인자 값에서도 찾아볼 수 있다.
            ```
            var b = 3;
            function foo( a = 42, b = a + b + 5 ){
                // ...
            }
            ```
            * 두 번째 할당문에서 좌변 b는 아직 TDZ에 남아 있는 b를 참조하려고 하기 때문에 ( 더 바깥쪽에서 끌어오지 못하고 ) 에러를 던진다.
            * 그러나 이 시점에서 인자 a는 TDZ를 밝고 간 이후여서 문제가 없다.
            * ES6 디폴트 인자 값은 함수에 인자를 넘기지 않거나 undefined를 전달했을 때 적용된다.
            ```
            function foo (a=42, b = a+1){
                consol.log(a, b)
            }
            foo(); // 42 43
            foo(undefined); // 42 43
            foo(5); // 5 6
            foo(void 0, 7) // 42 7
            foo(null) // null 1
            ```
            * ES6 디폴트 인자 입장에서 보면 인자 값이 없거나 undefined 값을 받거나 그게 그거다.
* try...finally
    * catch, finally 둘 다 같이 써도 상관없다.
    * finally 절의 코드는 (어떤 일이 있어도) 반드시 실행되고 다른 코드로 넘어가기 전에 try 이후 부터 (catch가 있으면 catch 다음부터) 항상 실행된다.
    * 어떤 의미에서 finally 절은 다른 블록 코드에 상관없이 필히 실행되어야 할 콜백 함수와 같다고 봐야 맞다.
    * 그런데 만약 try절에 return 문이 있으면?
    * 당연히 어떤 값을 반환할 텐데, 그 값을 반환받은 호출부 코드는 finally 이전에 실행될까? 아니면 이후에 실행될까?
    ```
    function foo(){
        try{
            return 42;
        }
        finally{
            console.log('hello')
        }
        console.log('x')
    }
    console.log(foo());
    // hello
    // 42
    ```
    * return 42에서 foo() 함수의 완료 값은 42로 세팅되고, try 절의 실행이 종료되면서 곧바로 finally 절로 넘어간다.
    * 그 후 foo() 함수 전체의 실행이 끝나고 완료 값은 호출부 console.log() 문에 반환된다.
    * try 안에 throw가 있어도 비슷하다.
    ```
     function foo(){
        try{
            throw 42;
        }
        finally{
            console.log('hello')
        }
        console.log('x')
    }
    console.log(foo());
    // hello
    // Uncaught Exception:42
    ```
    * 만약 finally 절에서 예외가 던저지면, 이전의 실행 결과는 모두 무시한다.
    * 즉, 이전에 try 블록에서 생성한 완료 값이 잇어도 완전히 사장된다.
    ```
    function foo(){
        try{
            return 42;
        }
        finally{
            throw 'errrrr'
        }
        console.log('x')
    }
    console.log(foo());
    // Uncaught Exception: errrrr
    ```
    * continue 나 break 같은 비선형 제어문 역시 return과 throw와 비슷하게 작동한다.
    ```
    for(var i = 0 ; i < 10 ; i ++){
        try{
            continue;
        }
        finally{
            console.log(i)
        }
    }
    // 0 1 2 3 4 5 6 7 8 9
    ```
    * continue 문 떄문에 console.log(i) 문은 루프 순회 끝 부분에서 실행된다.
    * 그러나 i++ 로 인덱스가 수정되기 직전까지 꾸준히 실행되므로 1...10이 아닌 0...9가 콘솔 창에 표시된다.
    * finally 절의 return은 그 이전에 실행된 try나 catch 절의 return을 덮어쓰는 특출한 능력이 있다.
    * 단 반드시 명시적으로 return 문을 써야한다.
    * 보통 함수에서는 return을 생략해도 return; 또는 return undefined; 한 것으로 치지만, finally안에서 return 을 빼면 이전의 return문을 무시하지 않고 존중한다.
* switch
    * switch 표현식과 case 표현식 간의 매칭 과정은 === 알고리즘과 똑같다.
    * == 를 사용하고 싶으면 꼼수를 좀 부려야 한다.
    ```
    var a = '42'
    switch(true){
        case a == 10:
            break;
        case a == 42:
            break;
    }
    ```
    * switch 표현 식의 결과(true) 와 case 표현식의 결과를 엄격하게 매치한다.
    * 단 truty 이지만 엄격히 true가 아닐 경우 매치는 실패한다
    ```
    var a = 'hello'
    var b = 10
    ...
    case( a || b == 10)
    ```
    * default 절은 선택 사항이며 꼭 끝 부분에 쓸 필요는 없다.
    * default 를 중간에 쓸 수도 있다.
    * default에서도 break를 안 써주면 그 이후로 코드가 계속 실행된다.

## 스코프란 무엇인가.
* 스코프
    * 변수는 어디에 살아있는가?
    * 변수는 어디에 저장되는가?
    * 필요할 떄 프로그램은 어떻게 변수를 찾는가?
    * 이 질문들을 통해 알 수 있는 것은 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데는 잘 정의된 규칙이 필요하다는 점이다.
    * 바로 이런 규칙을 Scope 라 한다.
* 컴파일러 이론
    * 자바스크립트는 일반적으로 '동적' 또는 '인터프리터' 언어로 분류하나 사실은 '컴파일러 언어'다.
    * 물론 자바스크립트가 전통적인 많은 컴파일러 언어처럼 코드를 미리 컴파일하거나 컴파일한 결과를 분산 시스템에서 이용할 수 있는 것은 아니다.
    * 하지만 자바스크립트 엔진은 전통적인 컴파일러 언어에서 컴파일러가 하는 일의 상당 부분을 우리가 아는 것보다 세련된 방식으로 처리한다.
    * 전통적인 컴파일러 언어의 처리 과정에서는 프로그램을 이루는 소스 코드가 실행되기 전에 보통 3단계를 거치는데, 이를 컴파일레이션이라고 한다.
        * 컴파일레이션
            * 토크나이징 Tokenizing / 렉싱 Lexing
                * 문자열을 나누어 토큰이라 불리는 의미 있는 조각으로 만드는 과정이다.
                * 예를 들어 var a = 2; 라는 프로그램을 보자.
                * 이 프로그램은 다음의 토큰으로 나눌 수 있다.
                ```
                var,
                a
                =
                2
                ;
                ```
                * 빈칸은 하나의 토큰으로 남을 수도 있고 아닐 수도 있다.
                * 이는 빈칸이 의미가 있느냐, 없느냐에 달렸다.
            * 파싱
                * 토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정이다.
                * 파싱의 결과로 만들어진 트리를 AST(Abstract Syntax Tree), 추상 구문 트리라 부른다.
                * var a = 2; 의 트리는 먼저 Variable Declaration (변수 선언)이라 부르는 최상위 노드에서 시작하고, 최상위 노드는 'a'의 값을 가지는 Identifier(확인자)와 Assignment Expression(대입 수식)이라 부르는 자식 노드를 가진다.
                * 대입 수식 노드는 '2'라는 값을 가지는 숫자 리터럴을 자식 노드로 가진다.
            * 코드 생성
                * AST를 컴퓨터에서 실행 코드로 바꾸는 과정이다.
                * 이 부분은 언어에 따라 또는 목표하는 플랫폼에 따라 크게 달라진다.
    * 자바스크립트 엔진은 이 세 가지 단계뿐 아니라 많은 부분에서 다른 프로그래밍 언어의 컴파일러보다 훨씬 복잡하다.
    * 자바스크립트 엔진이 기존 컴파일러와 다른 점은 자바스크립트 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않다는 것이다.
    * 자바스크립트 컴파일레이션은 보통 코드가 실행되기 겨우 수백만 분의 일초 전에 수행한다.
    * 자바스크립트 엔진은 가능한 가장 빠른 성능을 내기 위해 여러 종류의 트릭(Lazy compile, Hot recompile 같은 JITs)를 사용한다.
    * 간단히 말하자면, 어떤 자바스크립트 조각이라도 실행되려면 (보통 바로 직전에) 컴파일되어야 한다는 것이다.
    * 즉, 자바스크립트 컴파일러는 프로그램 var a = 2; 를 받아 컴파일하여 바로 실행될 수 있게 한다.
* 스코프 이해하기
    * 구성
        * 엔진
            * 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임진다.
        * 컴파일러
            * 엔진의 친구로, 파싱과 코드 생성의 모든 잡일을 도맡아 한다.
        * 스코프
            * 엔진의 또다른 친구로, 선언된 모든 확인자(변수) 검색 목록을 작성하고 유지한다.
            * 또한, 엄격한 규칙을 강제하여 현재 실행 코드에서 확인자의 적용 방식을 정한다.
    * 앞과 뒤
        * var a = 2; 를 보면 하나의 구문으로 보인다.
        * 그러나 엔진은 그렇게 보지 않는다.
        * 사실 엔진은 두 개의 서로 다른 구문으로 본다.
        * 하나는 컴파일러가 컴파일레이션 과정에서 처리할 구문이고, 다른 하나는 실행 과정에서 엔진이 처리할 구문이다.
        * var a = 2; 의 처리
            * 컴파일러가 할 첫 번쨰 일은 렉싱을 통해 구문을 토큰으로 쪼개는 것이다.
            * 그 후 토큰을 파싱해 트리 구조로 만든다.
            * 그러나 코드 생성 과정에 들어가면 컴파일러는 몇몇 독자의 추측과는 다르게 프로그램을 처리한다.
            * 컴파일러가 다음 의사코드로 요약될 수 있는 코드를 생성한다고 생각할 수 있다.
                * 변수를 위해 메모리를 할당하고 할당된 메모리를 a라 명명한 후 그 변수에 값 2를 넣는다.
            * 안타깝지만, 이는 그리 정확한 설명이 아니다.
                * var a
                    * 컴파일러가 'var a'를 만나면 스코프에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 물어본다.
                    * 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나간다.
                    * 그렇지 않으면 컴파일러는 새로운 변수 a 를 스코프 컬렉션 내에 선언하라고 요청한다.
                * a = 2
                    * 그 후 컴파일러는 'a = 2' 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다.
                    * 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다.
                    * 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳을 살핀다.
        * 엔진이 마침내 변수를 찾으면 값 2를 넣고, 못 찾는다면 엔진은 에러가 발생했음을 알린다.
        * 요약하면, 별개의 두 가지 동작을 취하여 변수 대입문을 처리한다.
        * 첫쨰, 컴파일러가 변수를 선언한다.
        * 둘쨰, 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.
* 컴파일러체
    * 2단계에서 컴파일러가 생성한 코드를 실행할 때 엔진은 변수 a가 선언된 적이 있는지 스코프에서 검색한다.
    * 이때 엔진이 어떤 종류의 검색을 하느냐에 따라 검색 결과가 달라진다.
    * 앞의 경우에서 엔진은 변수 a를 찾기 위해 LHS 검색을 수행한다.
    * 다른 종류의 검색은 RHS라 부른다.
    * L과 R은 left, right를 뜻한다.
    * 즉 LHS 검색은 변수가 대입 연산자의 왼쪽에 있을때 수행하고, RHS는 검색 변수가 대입 연산자의 오른쪽에 있을 때 수행한다.
    * RHS 검색은 단순히 특정 변수의 값을 찾는 것과 다를 바 없다.
    * 반면 LHS 검색은 값을 넣어야 하므로 변수 컨테이너 자체를 찾는다.
    * 따라서 정확히 말하면 RHS는 그 자체로는 '대입문의 오른쪽'이 아니다.
    * 좀 더 정확히 말하면 RHS는 '왼편이 아닌 쪽'에 가깝다.
    * 쉽게 말해, RHS를 '가서 값을 가져와라' 라고 할 수 있다.
    ```
    console.log(a);
    ```
    * a에 대한 참조는 RHS참조다.
    * 구문에서 a에 아무것도 대입하지 않기 때문이다.
    ```
    a = 2;
    ```
    * a에 대한 참조는 LHS 참조다.
    * 현재 a 값을 신경 쓸 필요 없이 '=2' 대입 연산을 수행할 대상 변수를 찾기 때문이다.
    * LHS = 대입할 대상
    * RHS = 대입한 값
    ```
    function foo(a){
        console.log(a); 2
    }
    foo(2);
    ```
    * 마지막 줄에서 foo() 함수를 호출하는 데 RHS참조를 사용한다.
    * 즉 '가서 foo의 값을 찾아 가져와라'라는 뜻이다.
    * 여기서 ()는 실행된다는 뜻이므로 foo는 함수여야 한다.
    * 이 부분에 미묘하지만 중요한 대입이 수행된다.
    * 인수로 값 2를 함수 foo()에 넘겨 줄 때 값 2를 인자 a에 대입하는 연산이 일어난다.
    * 이 인자 a 에 대한 대입 연산을 위해 LHS 검색이 수행된다.
    * 변수 a에 대한 RHS 참조 역시 수행되는데, 그 결괏값은 console.log() 함수에 넘겨진다.
    * 또 console.log() 가 실행되려면 참조가 필요하다.
    * console 객체를 RHS 검색하여 log메서드가 있는지 확인한다.
    * 마지막으로 값 2를 RHS로 불러온 변수 a를 통해 log()에 넘겨주는 과정에서 LHS/RHS를 주고받는 작업에 대한 개념을 짚어 보자.
    * 구현된 log()의 내부에는 인자가 있을 것이고, 첫번째 인자를 LHS 검색으로 찾아 2를 대입할 것이다.
* 중첩 스코프
    * 스코프는 확인자 이름으로 변수를 찾기 위한 규칙의 집합이다.
    * 그러나 대개 고려해야 할 스코프는 여러 개다.
    * 하나의 블록이나 함수는 다른 블록이나 함수 안에 중첩될 수 있으므로 스코프도 다른 스코프안에 중첩될 수 있다.
    * 따라서 대상 변수를 현재 스코프에서 발견하지 못하면 엔진은 다음 바깥의 스코프로 넘어가는 식으로 변수를 찾거나 글로벌 스코프라 부르는 가장 바깥 스코프에 도달할 때까지 계속한다.
    ```
    function foo(a){
        console.log(a+b);
    }
    var b = 2;
    foo(2) // 4
    ```
    * b에 대한 RHS 참조는 함수 foo 안에서 처리할 수 없고, 함수를 포함하는 스코프에서 처리한다.
    * 중첩 스코프를 탐사할 때 사용하는 간단한 규칙은 다음과 같다.
        * 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계씩 올라간다.
        * 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.
    * LHS/RHS 를 참조하려면 현재 층을 둘러보고, 찾지 못하면 상위 스코프로 이동하여 같은 작업을 반복한다.
* 오류
    * LHS와 RHS를 구분하는 것이 왜 중요할까?
    * 이 두 종류의 검색 방식은 변수가 아직 선언되지 않았을 때 서로 다르게 동작하기 때문이다.
    ```
    function foo(a){
        console.log(a+b);
    }

    foo(2) 
    ```
    * b에 대한 첫 RHS 검색이 실패하면 다시는 b를 찾을 수 없다.
    * 이렇게 스코프에서 찾지 못한 변수는 '선언되지 않은 변수'라 한다.
    * RHS 검색이 중첩 스코프 안 어디에서도 변수를 찾지 못하면 엔진이 'ReferenceError'를 발생시킨다.
    * 여기서 중요한 점은 발생된 오류가 ReferenceError 타입이라는 것이다.
    * 반면에, 엔진이 LHS 검색을 수행하여 변수를 찾지 못하고 최상위층에 도착할 때 프로그램이 'Strict Mode'로 동작하고 있는 것이 아니라면, 글로벌 스코프는 엔진이 검색하는 이름을 가진 새로운 변수를 생성해서 엔진에게 넘겨준다.
    * 즉, '없어, 없었지만 하나 만들어주지' 라고 생각하면 된다.
    * ES5 부터 지원하는 strict Mode는 Normal/Relaxed/Lazy Mode 와는 여러 면에서 다르게 작동한다.
    * 예를 들어, strict mode에서는 글로벌 변수를 자동으로 또는 암시적으로 생성할 수 없다.
    * 그래서 앞의 상황이 닥치면 글롭러 스코프는 변수를 생성하지 않아서 LHS 검색은 아무 것도 얻지 못하고, 엔진은 Reference Error를 발생시킨다.
    * 이제, RHS 검색 결과 변수를 찾았지만 그 값을 가지고 불가능한 일을 하려고 할 경우를 보자.
    * 예를 들어, 함수가 아닌 값을 함수처럼 실행하거나 null 이나 undefind 값을 참조할 때 엔진은 TypeError를 발생시킨다.
    * ReferenceError는 스코프에서 대상을 찾았는지와 관계가 있지만, TypeError는 스코프 검색은 성공했으나 결괏값을 가지고 적합하지 않거나 불가능한 시도를 한 경우를 의미한다.
* 정리하기
    * 스코프는 어디서 어떻게 변수를 찾는가를 결정하는 규칙의 집합이다.
    * 변수를 검색하나는 이유는 값을 대입하거나(LHS) 변수의 값을 얻어오기 위해서다(RHS).
    * LHS 참조는 대입 연산 과정에서 일어난다.
    * 스코프와 관련된 대입 연산은 '=' 연산자가 사용되거나 인자를 함수의 인자로 넘겨줄 때 일어난다.
    * 자바스크립트 엔진은 코드를 실행하기 전에 먼저 컴파일하는데, 이 과정에서 엔진은 'var a = 2;' 와 같은 구문을 독립된 두 단계로 나눈다.
        * var a 는 변수 a를 해당 스코프에 선언한다.
        * 이 단계는 코드 실행 전에 처음부터 수행된다.
        * a = 2 는 변수 a를 찾아 값을 대입한다.
    * LHS와 RHS 참조 검색은 모두 현재 실행 중인 스코프에서 시작한다.
    * 그리고 필요하다면 한 번에 한 스코프씩 중첩 스코프의 상위 스코프로 넘어가며 확인자를 찾는다.
    * 이 작업은 글로벌 스코프에 이를 때까지 계속하고 대상을 찾았든, 못 찾았든 작업을 중단한다.
    * RHS 참조가 대상을 찾지 못하면 ReferenceError가 발생한다.
    * LHS 참조가 대상을 찾지 못하면 자동적, 암시적으로 글로벌 스코프에 같은 이름의 새로운 변수가 생성된다.

## 렉시컬 스코프
* 스코프의 두 가지 작동 방식
    * 렉시컬 스코프
        * 일반적이고 다수의 프로그래밍 언어가 사용
    * 동적 스코프
        * bash scripting, perl의 일부 모드와 같은 몇몇 언어에서 사용
* 렉스 타임
    * 렉싱 처리 과정에서는 소스 코드 문자열을 분석하여 상태 유지 파싱의 결과로 생성된 토큰에 의미를 부여한다.
    * 바로 이 개념이 렉스컬 스코프가 무엇인지, 어원이 어디인지를 알게 해주는 바탕이 된다.
    * 렉시컬 스코프는 렉싱 타임에 정의되는 스코프다.
    * 바꿔 말해 렉시컬 스코프는 프로그래머가 코드를 짤 때 변수와 스코프 블록을 어디서 작성하는가에 기초해서 렉서가 코드를 처리할 떄 확정된다.
        * 뒤에서 렉시컬 스코프를 속여 렉서가 지나간 이후 수정하는 방법에 대해 알아볼 것이다.
        * 그러나 이는 권장하지 않는 방법이다.
        * 렉시컬 스코프를 수정하는 가장 좋은 방법은 오직 구문과 관련해서 변경하는 것, 즉 사실상 코드 작성 때만 수정하는 것이다.
    ```
    function foo(a){
        var b = a * 2;
        function bar(c){
            console.log(a, b, c)
        }
        bar (b * 3)
    }
    foo(2) // 2, 4, 12
    ```
    * 이 예제에는 3개의 중첩 스코프가 있다. (해당 스코프에 있는 확인자)
        * 글로벌 (foo)
        * foo (a, bar, b)
        * bar (c)
    * 스코프 버블은 스코프 블록이 쓰이는 곳에 따라 결정된다.
    * 스코프 블록은 서로 중첩될 수 있다.
    * bar의 버블은 foo의 버블 내부에 완전히 포함된다.
    * 바로 foo의 내부에서 bar 함수를 정의했기 때문이다.
    * 어떤 함수의 버블도 동시에 다른 두 스코프 버블 안에 존재할 수 없다.
    * 어떤 함수도 두 개의 부모 함수 안에 존재할 수 없다는 말이다.
* 검색
    * 엔진은 스코프 버블의 구조와 상대적 위치를 통해 어디를 검색해야 확인자를 찾을 수 있는지안다.
    * console.log() 구문을 실행하고 3개의 참조된 변수 a, b, c를 검색한다.
    * 검색은 가장 안쪽의 스코프 버블인 bar() 함수의 스코프에서 시작한다.
    * 여기서 a를 찾지 못하면 다음으로 가장 가까운 스코프 버블인 foo()의 스코프로 한 단계 올라가고, 이곳에서 a를 찾아 사용한다.
    * 변수 c가 bar()와 foo() 내부에 모두 존재한다고 가정하면, console.log() 구문은 bar() 내부에 있는 c를 찾아서 사용하고 foo()에는 c를 찾으러 가지도 않는다.
    * 스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단한다.
    * 여러 중첩 스코프 층에 걸쳐 같은 확인자 이름을 정의할 수 있다.
    * 이를 Shadowing이라 한다.
    * 섀도잉과 상관없이 스코프 검색은 항상 실행 시점에서 가장 안쪽 스코프에서 시작하여 최초 목표와 일치하는 대상을 찾으면 멈추고, 그전까지는 바깥/위로 올라가면서 수행한다.
    * 섀도잉으로 가려져 있는 글로벌 변수는 window. 를 통해 접근할 수 있지만, 글로벌 변수가 아닌 변수는 접근할 수 없다.
    * 어떤 함수가 어디서 또는 어떻게 호출되는지에 상관없이 함수의 렉시컬 스코프는 함수가 선언된 위치에 따라 정의된다.
* 렉시컬 속이기
    * 두 가지 방법이 있다.
    * 두 방법 모두 개발자 커뮤니티에서 권하지 않는 방법이다.
    * 성능을 떨어트리기 때문이다.
        * eval
            * 자바스크립트의 eval() 함수는 문자열을 인자로 받아들여 실행 시점에 문자열의 내용을 코드의 일부분처럼 처리한다.
            * 즉, 처음 작성한 코드에 프로그램에서 생성한 코드를 집어넣어 마치 처음 작성될 때부터 있던 것처럼 실행한다.
            * eval()의 성격을 생각해보면 eval()을 통해 어떻게 렉시컬 스코프를 수정하고 원래 작성했던 코드인 양 속일 수 있는지 이해할 수 있다.
            * eval()이 실행된 후 코드를 처리할 때 엔진은 지난 코드가 동적으로 해석되어 렉시컬 스코프를 변경시켰는지 알 수도 없고 관심도 없다.
            * 엔진은 그저 평소처럼 렉시컬 스코프를 검색할 뿐이다.
            ```
            function foo(str, a){
                eval(str);
                console.log(a, b)
            }
            var b = 2;
            foo("var b = 3;", 1) // 1, 3
            ```
            * 이코드는 새로운 변수 b를 선언하면서 이미 존재하는 foo()의 렉시컬 스코프를 수정한다.
            * 사실, 앞에서 언급한 것처럼 이 코드는 실제로 foo() 안에 변수 b를 생성하여 바깥 스코프에 선언된 변수 b를 가린다.
            * eval은 흔히 동적으로 생성된 코드를 실행할 때 사용된다.
            * eval()이 호출된 위치에 있는 렉시컬 스코프를 수정한다.
            * strict mode 프로그램에서 eval()을 사용하면 eval()은 자체적인 렉시컬 스코프를 이용한다.
                * 즉, eval()내에서 실행된 선언문은 현재 위치의 스코프를 실제로 수정하지 않는다.
        * with
            * 곧 없어질 기능이다.
    * 성능
        * 자바스크립트 엔진은 컴파일레이션 단게에서 상당수의 최적화 작업을 진행한다.
        * 이 최적화의 일부분이 하는 핵심 작업은 렉싱된 코드를 분석하여 모든 변수와 함수 선언문이 어디에 있는지 파악하고 실행하는 과정에서 확인자 검색을 더 빠르게 하는 것이다.
        * 그러나 eval()이 있다면 엔진은 미리 확부해둔 확인자의 위치가 틀릴 수도 있다고 가정해야한다.
        * 최적하 한 것이 의미가 없어져 버린다.
* 정리하기
    * 렉시컬 스코프란 프로그래머가 코드를 작성할 때 함수를 어디에 선언하는지에 따라 정의되는 스코프를 말한다.
    * 컴파일레이션의 렉싱 단계에서는 모든 확인자가 어디서 선언됐는지 파악하여 실행 단계에서 어떻게 확인자를 검색할지 예상할 수 있도록 도와준다.


## 함수 vs 블록 스코프
* 함수 기반 스코프
    * 자바스크립트는 함수 기반 스코프를 사용한다.
    ```
    function foo(a){
        var b = 2;

        function bar(){

        }

        var c = 3
    }
    ```
    * 앞의 코드에서 foo()의 스코프 버블은 확인자 a, b, c, bar를 포함한다.
    * 선언문이 스코프의 어디에 있는지는 중요하지 않다.
    * 스코프 안에 있는 모든 변수와 함수는 그 스코프 버블에 속한다.
    * bar()는 자체 스코프가 있고 글로벌 스코프도 마찬가지다.
    * 그리고 글로벌 스코프에는 foo 라는 확인자가 하나 있다.
    * a, b, c, bar 모두 foo()의 스코프 버블에 속하므로 foo() 바깥에서는 이들에게 접근할 수 없다.
    ```
    bar() // fails
    console.log(a, b, c) // all 3 fail
    ```
    * 하지만 이 모든 확인자는 foo()안에서 접근할 수 있고, bar() 안에서도 이용할 수 있다.
    * 함수 스코프는 모든 변수가 함수에 속하고 함수 전체에 걸쳐 사용되며 재사용된다는 개념을 확고하게 한다.
    * 이런 디자인 접근법은 상당히 유용하고 자바스크립트 변수의 동적 특성을 완전히 살려 다른 타입의 값을 필요에 따라 가져올 수 있지만, 스코프 전체에서 변수가 살아있다는 점이 예상치 못한 문제를 일으킬 수도 있다.
* 일반 스코프에 숨기
    * 함수에 대한 전통적인 개념은 이렇다.
        * 함수를 선언하고 그 안에 코드를 넣는다.
        * 작성한 코드에서 임의 부분을 함수 선언문으로 감싼다.
            * 이는 해당 코드를 숨기는 효과를 낸다.
        * 이렇게 하면 해당 코드 주위에 새로운 스코프 버블이 생성된다.
        * 즉, 감싸진 코드 안에 있는 모든 변수 또는 함수 선언문은 이전 코드에 포함됐던 스코프가 아니라 새로이 코드를 감싼 함수의 스코프로 묶인다.
        * 달리 말하면, 함수의 스코프로 둘러싸서 변수와 함수를 '숨길' 수 있다는 말이다.
        * 그렇다면 코드를 '숨기는' 테크닉이 어디에 유용할까
            * 소프트웨어 디자인 원칙인 '최소 권한의 원칙'과 관련이 있다.
            * 이 원칙은 모듈/객체의 APU와 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 숨겨야 한다는 것이다.
            * 이 원칙은 어떤 스코프가 변수와 함수를 포함하는지에 관한 문제와도 관련있다.
            * 모든 변수와 함수가 글로벌 스코프에 존재한다면 어느 중첩된 하위 스코프에서도 이들에 접근할 수 있다.
            * 이는 '최소...' 원칙에 어긋난다.
            * 코드를 적절하게 사용했을 때 접근할 필요가 없어서 비공개로 남겨둬야 할 많은 변수나 함수를 노출시키게 된다.
* 충돌 회피
    * 변수와 함수를 스코프 안에 '숨기는 것'의 또 다른 장점은 같은 이름을 가졌지만 다른 용도를 가진 두 확인자가 충돌하는 것을 피할 수 있다.
    * 글로벌 '네임스페이스'
        * 글로벌 스코프에서 변수 충돌이 특히 일어나기 쉬운 경우에 대해 알아보자.
            * 내부/비공개 함수와 변수가 적절하게 숨겨져 있지 않은 여러 라이브러리를 한 프로그램에서 불러오면 라이브러리들은 서로 쉽게 충돌한다.
            * 이런 라이브러리는 일반적으로 글로벌 스코프에 하나의 고유 이름을 가지는 객체 선언문을 생성한다.
            * 이후 객체는 해당 라이브러리의 '네임스페이스'로 이용된다.
            * 네임스페이스를 통해 최상위 스코프의 확인자가 아니라 속성 형태로 라이브러리의 모든 기능이 노출된다.
            ```
            var noh ={
                a:42,
                doSomething: function(){

                },
                doAnotherThing: function(){

                }
            }
            ```
    * 모듈 관리
        * 좀 더 현대적인 충돌 방지 옵션으로는 다양한 의존성 관리자를 이용한 '모듈' 접근법이 있다.
        * 이 도구를 사용하면 어떤 라이브러리도 확인자를 글롭러 스코프에 추가할 필요가 없다.
        * 특정 스코프로부터 의존성 관리자를 이용한 다양한 명시적인 방법으로 확인자를 가져와 사용할 수 있다.
        * 기억할 것은 이런 도구를 사용한다고 마법처럼 렉시컬 스코프 규칙에서 벗어날 수 있는 것이 아니다.
        * 의존성 관리자는 그저 여기서 설명한 스코프 규칙을 저용해 모든 확인자가 공유 스코프에 누출되는 것을 방지하고, 우발적인 스코프 충돌을 예방하기 위해 충돌 위험이 없는 비공개 스코프에 확인자를 보관한다.
        * 물론 하려고 한다면 방어적으로 코딩하여 실제 의존성 관리자를 사용하지 않고도 사용한 것과 같은 결과를 얻을 수 있다.
        * 클로저를 참고하라
* 스코프 역할을 하는 함수
    ```
    var a = 2;
    (function foo(){
        var a = 3;
        console.log(a)
    })()
    console.log(a)
    ```
    * 코드를 감싼 함수는 선언문이 아니라 함수 표현식으로 취급된다.
        * function이 구문의 시작 위치에 있다면 선언문이고, 다른 경우엔 표현식이라고 생각해도 된다.
    * foo는 바깥 스코프에서는 발견되지 않는다.
    * 함수 이름 foo를 자기 내부에 숨기면 함수를 둘러싼 스코프를 불필요하게 오염시키지 않는다.
* 익명 vs 기명
    * 함수 선언문에는 이름이 빠져서는 안된다.
    * 함수 표현식은 이름 없이 사용할 수 있다.
    * 익명 함수 표현식은 빠르고 쉽게 입력할 수 있어서 많은 라이브러리와 도구가 권장한다.
    * 그러나 함수 표현식은 몇 가지 단점이 있다.
        * 익명 함수는 스택 추적 시 표시할 이름이 없어서 디버깅이 더 어려울 수 있다.
        * 이름 없이 함수 스스로 재귀 호풀을 하려면 불행히도 폐기 예정인 arguments.callee 참조가 필요하다.
            * 자기 참조가 필요한 또 다른 예로는 한 번 실행하면 해제되는 이벤트 처리 함수가 있다.
        * 이름은 보통 쉽게 이해하고 읽을 수 있는 코드 작성에 도움이 되는데, 익명 함수는 이런 이름을 생략한다.
    * 인라인 함수 표현식은 매우 효과적이고 유용하다.
    * 익명이냐 기명이냐의 문제가 이 사실을 퇴색시키지는 않는다.
    * 함수 표현식에 이름을 사용하면 특별한 부작용 없이 상당히 효과적으로 앞의 단점을 해결할 수 있다.
    * 따라서 함수 표현식을 사용할 떄 이름을 항상 쓰는 것이 가장 좋더.
* 함수 표현식 즉시 호출하기
    * ()로 함수를 감싸면 함수를 표현식으로 바꾼다.
    * (function foo(){})() 처럼 마지막에 또 다른 () 를 붙이면 함수를 실행할 수 있다.
    * 이런 패턴은 굉장히 흔해서 개발자 커뮤니티에서는 이것을 IIFE라는 용어로 정하였다.
        * Immediately Invoked Function Expression
    * 물론, IIFE는 이름이 꼭 필요하지는 않다.
    * IIFE는 익명 함수 표현식으로 가장 흔하게 사용된다.
    * 하지만 기명을 사용하면 앞서 언급한 것처럼 더 나은 면이 있다.
    * 따라서 기명 IIFE를 싸용하는 것은 좋은 습관이다.
    ```
    var a = 2;
    (function IIFE(global){
        var a = 3;
        console.log(a, global.a)
    })(window)
    ```
    ```
    var a = 2;
    (function IIFE(def){
        def(window)
    }(function def(global){
        var a = 3;
        console.log(a)
        console.log(global.a)
    }))
    ```
    * 이 방식은 약간 장황해도 이해하기에는 좀더 깔끔하다.
* 스코프 역할을 하는 블록
    * 함수가 가장 일반적인 스코프 단위이자 현재 자바스크립트에서 통용되는 가장 널리 퍼진 다지안 접근법이기는 하지만, 다른 스코프 단위도 존재하고 이를 활용하면 더 좋은 깔끔한 코드를 작성할 수 있다.
    ```
    for(var i = 0 ; i < 10 ; i ++){
        console.log(i)
    }
    ```
    * 변수 i를 for 반복문의 시작부에 선언하는 이유는 보통 i를 for 반복문과 관련해서 사용하려 하기 떄문이다.
    * 그러고는 변수 i가 실제로는 둘러싼 스코프에 포함된다는 사실을 무시한다.
    * 블록 스코프의 목적은 바로 이것이다.
    * 변수를 최대한 사용처 가까이에서 최대한 작은 유효 범위를 갖도록 선언하는 것 말이다.
    * 오직 for 반복문에서만 사용될 변수 i로 함수 스코프 전체를 왜 오염시켜야 할까?
    * 무엇보다 개발자들은 의도하지 않게 변수가 원래 용도 이외의 곳에서 (재)사용됐는지 점검하고 싶어한다.
    * 블록 스코프를 사용한다면 변수 i는 오직 for 반복문 안에서만 사용할 수 있고, 이외 함수 어느 곳에서 접근하더라도 오류가 발생할 것이다.
    * 그러나 슬픈 현실은 적어도 외견상으로 자바스크립트는 블록 스코프를 지원하지 않는다.
    * 물론, 좀 더 파고들면 방법은 있다.
    * try/catch
        * 잘 알려지지 않은 사실이지만, 자바스크립트 ES3에서 try/catch 문 중 catch 부분에서 선언된 변수는 catch 블록 스코프에 속한다.
        ```
        try{
            // err code....
        }catch(err){
            console.log(err) // wokrs!
        }
        console.log(err) // ReferenceError
        ```
    * let
        * 지금까지 살펴본 자바스크립트의 블록 스코프 기능은 비주류적인 요소를 통해 구현된 것이다.
        * 자바스크립트의 블록 스코프 기능이 이것뿐이었다면 자바스크립트 개발자들에게 블록 스코프는 별로 유용하지 않았을 것이다.
        * 다행히도, ES6에서 이런 상황이 바뀌면서 새로운 키워드 let이 채택됐다.
        * let은 var 같이 변수를 선언하는 다른 방식이다.
        * 키워드 let은 선언된 변수를 둘러싼 아무 블록(일반적으로 {})의 스코프에 붙인다.
        * 바꿔 말해, 명시적이진 않지만 let은 선언한 변수를 위해 해당 블록 스코프를 이용한다고 말할 수 있다.
        ```
        var foo = true
        if(foo){
            var bar = foo * 2
        }
        console.log(bar) // 2

         var foo = true
        if(foo){
            let bar = foo * 2
        }
        console.log(bar) // ReferenceError
        ```
        * 첫 예제의 스코프는 '가짜' 블록 스코프이다.
        * bar를 의도치 않게 다른 곳에서 사용하지 않도록 상기시키는 역할만 할 뿐이다.
        * let을 이용해 변수를 현재 블록에 붙이는 것은 약간 비명시적이다.
        * 코드를 작성하다 보면 블록이 왔다 갔다 하고 다른 블록을 감싸기도 하는데, 이럴 때 주의하지 않으면 변수가 어느 블록 스코프에 속한 것인지 착각하기 쉽다.
        * 블록 스코프에 사용하는 블록을 명시적으로 생성하면 이런 문제를 해결할 수 있다.
        * 변수가 어느 블록에 속했는지 훨씬 더 명료해지기 때문이다.
        * 일반적으로 명시적인 코드가 암시적이고 미묘한 코드보다 낫다.
        ```
        var foo =true
        if (foo){
            {
                let bar = foo * 2
            }
        }
        console.log(bar) // ReferenceError
        ```
        * let을 사용한 선언문은 속하는 스코프에서 호이스팅 효과를 받지 않는다.
        * 따라서 let 으로 선언된 변수는 실제 선언문 전에는 명백하게 '존재'하지 않는다.
        ```
        console.log(a) // undefined
        var a = 2

        console.log(a) // ReferenceError
        let a = 2
        ```
    * 가비지 콜랙션
        * 블록 스코프가 유용한 또 다른 이유는 메모리를 회수하기 위한 클로저 그리고 가비지 클랙션과 관련 있다.
        ```
        function process(data){
            //
        }
        
        var someReallyBigData ={ ... };

        process(someReallyBigData);

        var btn = document.getElementById('my-button');
        btn.addEventListener('click', function click(evt){
            console.log('button clicked')
        })
        ```
        * 클릭을 처리하는 함수는 someReallyBigData 변수가 전혀 필요 없다.
        * 따라서 이론적으로는 process()가 실행된 후 많은 메모리를 먹는 자료 구조인 someReallyBigData는 수거할 수도 있다.
        * 그러나 자바스크립트 엔진은 그 데이터를 여전히 남겨둘 것이다.
        * click 함수가 해당 스코프 전체의 클로저를 가지고 있기 때문이다.
        * 블록 스코프는 엔진에게 someReallyBigData가 더는 필요 없다는 사실을 더 명료하게 알려서 이 문제를 해결할 수 있다.
        ```
        function process(data){
            //
        }
        {
            let someReallyBigData ={ ... };
            process(someReallyBigData);
        }

        var btn = document.getElementById('my-button');
        btn.addEventListener('click', function click(evt){
            console.log('button clicked')
        })
        ```
        * 명시적으로 블록을 선언하여 변수의 영역을 한정하는 것은 효과적인 코딩 방식이므로 익혀두면 좋다.!!
    * let 반복문
        * let은 단지 i를 for 반복문에 묶었을 뿐만 아니라 반복문이 돌 때마다 변수를 다시 묶어서 이전 반복의 결괏값이 제대로 들어가도록 한다.
        ```
        {
            let j;
            for(j = 0 ; j < 10 ; j ++){
                let i = j;
                console.log(i)
            }
        }
        ```
        * 이런 반복마다 다시 묶는 작용이 흥미로운 이유는 클로저에서 명확하게 알 수 있다.
        * let 선언문은 둘러싼 함수 스코프가 아니라 가장 가까운 임의의 블록에 변수를 붙인다.
        * 따라서 이전에 var 선언문을 사용해서 작성된 코드는 함수 스코프와 숨겨진 연계가 있을 수 있으므로 코드 리팩토링을 위해서는 단순히 var를 let으로 바꾸는 것 이상의 노력이 필요하다.
    * const
        * ES6에는 키워드 let과 함꼐 const도 추가됐다.
        * 키워드 const 역시 블록 스코프를 생성하지만, 선언된 값은 고정된다.
        * 선언된 후 const의 값을 변경하려고 하면 오류가 발생한다.

* 정리하기
    * 자바스크립트에서 함수는 스코프를 이루는 가장 흔한 단위다.
    * 다른 함수 안에서 선언된 변수와 함수는 본질적으로 다른 '스코프'로부터 '숨겨진' 것이다.
    * 이는 좋은 소프트웨어를 위해 적용해야 할 디자인 원칙이다.
    * 그러나 함수는 결코 유일한 스코프 단위가 아니다.
    * 블록 스코프는 함수만이 아니라 (일반적으로 { }) 임의의 코드 블록에 변수와 함수가 속하는 개념이다.
    * ES3부터 시작해서 try/catch 구조의 catch 부분은 블록 스코프를 가진다.
    * ES6에서는 키워드 let이 추가되어 임의의 코드 블록 안에 변수를 선언할 수 있게 되었다.
    * if(){let a = 2}에서 변수 a는 if문의 { } 블록 스코프에 자신을 붙인다.
    * 쉽게 착각하지만, 블록 스코프는 var 함수 스코프를 완전히 대페할 수 없다.
    * 두 기능은 공존하며 개발자들은 함수 스코프와 블록 스코프 기술을 같이 사용할 수 있어야 하고 그래야 한다.
    * 상황에 따라 더 읽기 쉽고 유지 보수가 쉬운 코드를 작성하기 위해 두 기술을 적절한 곳에 사용하면 된다.

## 호이스팅
* 선언문이 스코프의 어디에 있는지에 따라 스코프에 변수가 추가되는 과정에 미묘한 차이가 있다.
    ```
    a = 2
    var a;
    consol.log(a) // 2

    console.log(a)
    var a // undefined
    ```

* 컴파일러는 두 번 공격한다.
    * 자바스크립트 엔진이 코드를 인터프리팅하기 전에 컴파일을 한다.
    * 컴파일레이션 단계 중에는 모든 선언문을 찾아 적절한 스코프에 연결해주는 과정이 있었다.
        * 바로 이 과정이 렉시컬 스코프의 핵심이다.
    * 변수와 함수 선언문 모두 코드가 실제 실행되기 전에 먼저 처리된다고 볼 수 있다.
    * var a = 2 를 자바스크립트는 2개의 구문으로 본다.
        * var a;
        * a = 2;
    * 첫째 구문은 선언문으로 컴파일레이션 단계에서 처리된다.
    * 둘째 구문은 대입문으로 실행 단계 까지 내버려둔다.
    * 따라서 첫 번째 코드 조각은 다음과 같이 처리된다.
    ```
    var a;
    a = 2;
    console.log(a)
    ```
    * 첫째 부분은 컴파일레이션 과정이고, 두번째 부분은 실행 과정이다.
    * 비슷한 방식으로 두 번째 코드 조각은 다음과 같이 처리된다.
    ```
    var a;
    console.log(a)
    a = 2
    ```
    * 이렇게 선언문을 끌어 올리는 동작을 '호이스팅' 이라고 한다.
    * 즉, 선언문이 대입문보다 먼저다.
    * 선언문만 끌어올려지고 다른 대입문이나 실행 로직 부분은 제자리에 그대로 둔다.
    * 호이스팅이 스코프별로 작동한다는 점도 중요하다.
    * 함수 선언문은 표현식과 다르다.
    ```
    foo();
    function foo(){

    }
    ->
    function foo(){

    }
    foo();
    ```
    ```
    foo(); // TypeError
    bar() // ReferenceError
    var foo = function bar(){

    }
    ->
    var foo;
    foo();
    bar();
    foo = function(){
        var bar = ...
    }
    ```
    * 또한 함수 표현식이 이름을 가져도 그 이름 확인자는 해당 스코프에서 찾을 수 없다.
* 함수가 먼저다.
    * 함수와 변수 선언문은 모두 끌어올려진다.
    * 그러나 먼저 함수가 끌어올려지고 다음으로 변수가 온다.
    ```
    foo()
    var foo;
    function foo(){
        console.log(1)
    }
    foo = function(){
        console.log(2)
    }
    ->
    function foo(){
        console.log(1)
    }
    foo();
    foo = function(){
        console.log(2)
    }
    ```
    * var foo가 중복(그래서 무시된) 선언문이라는 점을 보자.
    * var foo는 function foo() 선언문보다 앞서 선언됐지만, 함수 선언문이 일반 변수 위로 끌어올려졌다.
    * 많은 중복 변수 선언문이 사실상 무시됐지만 중복 함수 선언문은 앞선 것들을 겹쳐 쓴다.
    ```
    foo(); // 3
    function foo(){
        console.log(1)
    }
    var foo = function (){
        console.log(1)
    }
    function foo(){
        console.log(3)
    }
    ```
* 정리하기
    * 'var a = 2'는 하나의 구문처럼 보이지만, 자바스크립트 엔진은 그렇게 보지 않는다.
    * 엔진은 이를 var a 와 a = 2 라는 두 개의 독립된 구문으로 본다.
    * 첫째 구문은 컴파일러 단계에서 처리하고 둘쨰 구문은 실행 단계에서 처리한다.
    * 이것을 의미하는 바는 스코프의 모든 선언문은 어디서 나타나든 실행 전에 먼저 처리된다는 점이다.
    * 호이스팅이라 불리는 이 과정은 선언문 각각이 속한 스코프의 꼭대기로 끌어올려지는 작업이라고 생각할 수 있다.
    * 그 과정에서 선언문 자체는 옮겨지지만, 함수 표현식의 대입문을 포함한 모든 대입문은 끌어올려 지지 않는다.
    * 중복 선언을 조심해야한다.
    * 일반 변수 선언과 함수 선언을 섞어 사용하면 특히 더 위험하다.

## 스코프와 클로저
* 도입
    * 클로저는 렉시컬 스코프에 의존해 코드를 작성한 결과로 그냥 발생한다.
    * 이용하려고 굳이 의도적으로 생성할 필요도 없다.
    * 모든 코드에서 클로즈는 생성되고 사용된다.
* 핵심
    * 클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 떄에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.
    ```
    function foo(){
        var a = 2;
        function bar(){
            console.log(a)
        }
        bar()
    }
    foo()
    ```
    * 앞의 코드는 중첩 스코프를 다룰 때 보았던 예제와 비슷하다.
    * 함수 bar()는 렉시컬 스코프 검색 규칙을 통해 바깥 스코프의 변수 a에 접근할 수 있다.
    * a를 참조하는 bar()를 설명하는 가장 정확한 방식은 렉시컬 스코프 검색 규칙에 따라 설명하는 것이고, 이 규칙은 클로저의 일부일 뿐이다.
    * 순전히 학술적인 관점에서 앞의 코드에 대해 말하면 함수 bar()는 foo() 스코프에 대한 클로저를 가진다.
        * 물론 bar()는 그 외의 접근 가능한 (이 경우에는 글로벌) 스코프에 대한 클로저도 가진다.
    * 달리 말하면 bar()는 foo() 스코프에서 닫힌다.
    * 왜 일까?
    * bar()는 중첩되어 foo() 안에 존재하기 때문이다.
    * 그러나 이런 방식으로 정의된 클로저는 바로 알아보기 힘들고 앞의 코드에서 클로저가 작동하는 방식을 볼 수도 없다.
    ```
    function foo(){
        var a = 2;
        function bar(){
            console.log(a)
        }
        return bar
    }
    var baz = foo();
    baz() // 2
    ```
    * 함수 bar()는 foo()의 렉시컬 스코프에 접근할 수 있고, bar() 함수 자체를 값으로 넘긴다.
    * 이 코드는 bar를 참조하는 함수 객체 자체를 반환한다.
    * foo()를 실행하여 반환 값을 baz라 불리는 변수에 대입하고 실제로는 baz() 함수를 호출했다.
    * 이는 당연하게도 그저 다른 확인자 참조로 내부 함수인 bar() 를 호출한 것이었다.
    * bar()는 의심할 여지 없이 실행됐다.
    * 그러나 이 경우에 함수 bar는 함수가 선언된 렉시컬 스코프 밖에서 실행됐다.
    * 일반적으로 foo()가 실행된 후에는 foo()의 내부 스코프가 사라졌다고 생각할 것이다.
    * 이것은 엔진이 가비지 콜렉터를 고용해 더는 사용하지 않는 메모리를 해제시킨다는 사실을 알기 때문이다.
    * 더는 foo()의 내용을 사용하지 않는 상황이라면 사라졌다고 보는 게 자연스럽다.
    * 그러나 클로저의 마법이 이를 내버려두지 않는다.
    * 사실 foo의 내부 스코프는 여전히 '사용 중'이므로 해제되지 않는다.
    * 그럼 누가 그 스코프를 사용중인가?
    * 바로 bar() 자신이다.
    * 선언된 위치 덕에 bar()는 foo() 스코프에 대한 렉시컬 스코프 클로저를 가지고, foo()는 bar()가 나중에 참조할 수 있도록 스코프를 살려둔다.
    * 즉, baz()는 여전히 해당 스코프에 대한 참조를 가지는데, 그 참조를 클로저라고 부른다.
    * foo() 선언이 끝나고 수 밀리 초 후 변수 baz를 호출 할 때, 해당 함수는 원래 코드의 렉시컬 스코프에 접근할 수 있고 예상한 것처럼 이는 함수가 변수 a에 접근할 수 있다는 의미다.
    * 함수는 원래 렉시컬 스코프에서 완전히 벗어나 호출됐다.
    * 클로저는 호출된 함수가 원래 선언된 렉시컬 스코프에 계속해서 접근할 수 있도록 허용한다.
    * 물론, 어떤 방식이든 함수를 값으로 넘겨 다른 위치에서 호출하는 행위는 모두 클로저가 작용한 예다.
    ```
    function foo(){
        var a = 2;
        function baz(){
            console.log(a)
        }
        bar(baz)
    }

    function bar(fn){
        fn()
    }
    ```
    * 코드에서 함수 baz를 bar에 넘기고, 이제 fn이라 명명된 함수를 호출했다.
    * 이때 foo()의 내부 스코프에 대한 fn의 클로저는 변수 a에 접근할 떄 확인할 수 있었다.
    * 이런 함수를 넘기기는 간접적인 방식으로도 가능하다.
    ```
    var fn;
    
    function foo(){
        var a = 2;
        function baz(){
            console.log(a)
        }
        fn = baz
    }
    function bar(){
        fn()
    }

    foo()

    bar()//2
    ```
    * 어떤 방식으로 내부 함수를 자신이 속한 렉시컬 스코프 밖으로 수송하든 함수는 처음 선언된 곳의 스코프에 대한 참조를 유지한다.
    * 즉, 어디에서 해당 함수를 실행하든 클로저가 작용한다.
* 이제 나는 볼 수 있다.
    * 앞에서 본 코드들은 클로저 사용법을 보여주기 위해 다소 학술적이고 인우적으로 작성했다.
    ```
    function wait(message){
        setTimeout(function timer(){
            console.log(message)
        },1000)
    }
    wait('Hello, closure');
    ```
    * 내부 함수 timer를 setTimeout()에 인자로 넘겼다.
    * timer 함수는 wait() 함수의 스코프에 대한 스코프 클로저를 가지고 있으므로 변수 message에 대한 참조를 유지하고 사용할 수 있다.
    * wait() 실행 1초 후, wait의 내부 스코프는 사라져야 하지만 익명의 함수가 여전히 해당 스코프에 대한 클로저를 가지고 있다.
    * 엔진 내부 깊숙한 곳의 내장 함수 setTimeout()에는 아마도 fn이나 func 정도로 불릴 인자의 참조가 존재한다.
    * 엔진은 해당 함수 참조를 호출하여 내장 함수 timer를 호출하므로 timer의 렉시컬 스코프는 온전하게 남아있다.
* 클로저
    * 자체의 렉시컬 스코프에 접근할 수 있는 함수를 인자로 넘길 떄 그 함수가 클로저를 사용하는 것을 볼 수 있다.
    * 타이머, 이벤트 처리기, Ajax 요청, 윈도 간 통신, 웹 워커와 같은 비동기적(또는 동기적) 작업을 하며 콜백 함수를 넘기면 클로저를 사용할 준비가 된 것이다.
    ```
    var a =2;
    (function IIFE(){
        console.log(a)
    })()    
    ```
    * 이 코드는 작동하지만 엄격히 말해 클로저가 사용된 것은 아니다.
    * IIFE 함수가 자신의 렉시컬 스코프 밖에서 실행된 것이 아니기 떄문이다.
    * IIFE 함수는 선언된 바로 그 스코프 안에서 호출됐다.
    * 변수 a는 클로저가 아니라 일반적인 렉시컬 스코프 검색을 통해 가져왔다.
    * IIFE 자체는 클로저의 사례가 아니지만, IIFE는 틀림없이 스코프를 생성하고 클로저를 사용할 수 있는 스코프를 만드는 가장 흔한 도구의 하나다.
    * 따라서 IIFE 자체가 클로저를 작동시키지는 않아도 확실히 클로저와 연관이 깊다.
* 반복문과 클로저
    * 클로저를 설명하는 가장 흔하고 표준적인 사례는 for 반복문이다.
    ```
    for(var i = 1 ; i <= 20 ; i ++){
        setTimeout(function timer(){
            console.log(i)
        },i*1000)
    }
    ```
    * 6만 5번 출력된다.
    * 즉, 출력된 값은 반복문이 끝났을 때의 i 값을 반영한 것이다.
    * timeout 함수 콜백은 반복문이 끝나고 나서야 작동한다.
    * 사실, 타이머를 차치하고 반복마다 실행된 것이 setTimeout(...,0) 이었다 해도 해당 함수 콜백은 확실히 반복문이 끝나고 나면 동작해서 결과를 매번 6으로 출력한다.
    * 여기서 더 심오한 문제가 제기된다.
    * 애초에 문법적으로 기대한 것과 같이 이 코드를 작동시키려면 무엇이 필요할까?
    * 그러기 위해 필요한 것은 반복마다 각각의 i 복제본을 잡아두는 것이다.
    * 그러나 반복문 안 총 5개의 함수들은 반복마다 따로 정의됐음에도 모두 같이 글로벌 스코프 클로저를 공유해 해당 스코프 안에는 오직 하나의 i만이 존재한다.
    * 따라서 모든 함수는 당연하게도 같은 i에 대해 참조를 공유한다.
    * 그냥 5개의 timeout 콜백을 쭉 이어서 반복문 없이 선언해도 결과는 똑같다.
    * 필요한 것은 더 많은 닫힌 스코프다.
    * 구체적으로 말하면 반복마다 하나의 새로운 닫힌 스코프가 필요하다.
    ```
    for(var i = 1 ; i <= 20 ; i ++){
        (function(){
            setTimeout(function timer(){
                console.log(i)
            },i*1000)
        })
    }
    ```
    * 결과는 작동하지 않는다.
    * timeout 함수 콜백은 확실히 반복마다 각각의 IIFE가 생성한 자신만의 스코프를 가진다.
    * 그러나 닫힌 스코프만으로는 부족하다.
    * 이 스코프가 비어있기 때문이다.
    * IIFE는 아무것도 하지 않는 빈 스코프일 뿐이니 무언가 해야 한다.
    * 각 스코프는 자체 변수가 필요하다.
    * 즉, 반복마다 i의 값을 저장할 변수가 필요하다.
    ```
    for(var i = 1 ; i <= 20 ; i ++){
        (function(){
            var j = i
            setTimeout(function timer(){
                console.log(j)
            },i*1000)
        })()
    }
    ```
    * 약간 다른 버전도 있다.
     ```
    for(var i = 1 ; i <= 20 ; i ++){
        (function(j){
            setTimeout(function timer(){
                console.log(j)
            },i*1000)
        })(i)
    }
    ```
    * IIFE를 사용하여 반복마다 새로운 스코프를 생성하는 방식으로 timeout 함수 콜백은 원하느 ㄴ값이 제대로 저장된 변수를 가진 새 닫힌 스코프를 반복마다 생성해 사용할 수 있다.
    * 반복마다 IIFE를 사용해 하나의 새로운 스코프를 생성했다.
    * 다시 말하면, 실제 필요했던 것은 반복 별 블록 스코프였다.
    * 키워드 let은 본질적으로 하나의 블록을 닫을 수 있는 스코프로 바꾼다.
    ```
    for (let i = 0; i < 5; i++) {
        setTimeout(function() {
            console.log(i);
        }, i * 1000);
    }
    ```
    * 반복문 시작 부분에서 let으로 선언된 변수는 한 번만 선언되는 것이 아니라 반복할 때마다 선언된다.
    * 따라서 해당 변수는 편리하게도 반복마다 이전 반복이 끝난 이후의 값으로 초기화된다.
* 모듈
    * 클로저의 능력을 활용하면서 표면적으로는 콜백과 상관없는 코드 패턴들이 있다.
    * 그중 가장 강력한 패턴인 모듈을 살펴보자
    ```
    function foo(){
        var something = 'cool';
        var another = [1, 2, 3];

        function doSomething(){
            console.log(something);
        }
        function doAnother(){
            console.log(antoher.join(' ! '));
        }
    }
    ```
    * 이 코드에는 클로저의 흔적이 보이지 않는다.
    * 우리가 볼 수 있는 것은 몇 가지 비공개 데이터 변수인 something과 another그리고 내부 함수 doSomething()과 doAnother()가 있다.
    * 이들 모두 foo()의 내부 스코프를 렉시컬 스코프로 가진다.
    ```
    function CoolModule(){
        var something = 'cool';
        var another = [1, 2, 3];

        function doSomething(){
            console.log(something);
        }
        
        function doAnother(){
            console.log(antoher.join(' ! '));
        }
        return{
            doSomething: doSomething,
            doAnother: doAnother
        }
    }
    var foo = CoolModule();
    
    foo.doSomething(); // cool
    foo.doAnother(); // 1 ! 2 ! 3
    ```
    * 이 코드와 같은 자바스크립트 패턴을 Module이라 부른다.
    * 가장 흔한 모듈 패턴 구현 방법은 Revealing Module (모듈 노출)이고, 앞의 코드는 이것의 변형이다.
        * 첫쨰, CoolModule()은 그저 하나의 함수일 뿐이지만, 모듈 인스턴스를 생성하려면 반드시 호출해야 한다.
            * 최외곽 함수가 실행되지 않으면 내부 스코프와 클로저는 생성되지 않는다.
        * 둘쨰, CoolModule()함수는 객체를 반환한다.
        * 반환되는 객체는 객체-리터럴 문법 {key: value, ...}에 따라 표기된다.
        * 해당 객체는 내장 함수들에 대한 참조를 가지지만, 내장 데이터 변수에 대한 참조는 가지지 않는다.
        * 내장 데이터 변수는 비공개로 숨겨져 있다.
        * 이 객체의 반환 값은 본질적으로 모듈의 공개 API라고 생각할 수 있다.
        * 객체의 반환 값은 최종적인 외부 변수 foo에 대입되고, foo.doSomething()과 같은 방식으로 API의 속성 메서드에 접근할 수 있다.
            * 모듈에서 꼭 실제 객체를 반환할 필요 없지 직접 내부 함수를 반환해도 된다.
        * 함수 doSomething()과 doAnother()은 모듈 인스턴스의 내부 스코프에 포함하는 클로저를 가진다.
        * 반환된 객체에 대한 속성 참조 방식으로 이 함수들을 해당 렉시컬 스코프 밖으로 옮길 때 클로저를 확인하고 이용할 수 있는 조건을 하나 세웠다.
        * 쉽게 말해, 이 모듈 패턴을 사용하려면 두 가지 조건이 있다.
            * 하나의 최외각 함수가 존재하고, 이 함수가 최소 한 번은 호출되어야 한다.
                * 호출할 때마다 새로운 모듈 인스턴스가 생성된다.
            * 최외각 함수는 최소 한 번은 하나의 내부 함수를 반환해야 한다.
                * 그래야 해당 내부 함수가 비공개 스코프에 대한 클로저를 가져 비공개 상태에 접근하고 수정할 수 있다.
        * 하나의 함수 속성만을 가지는 객체는 진정한 모듈이 아니다.
        * 함수 실행 결과로 반환된 객체에 데이터 속성들은 있지만 닫힌 함수가 없다면, 당연히 그 객체는 진정한 모듈이 아니다.
        * 앞의 코드는 독립된 모듈 생성자 CoolModule() 을 가지고, 생성자는 몇 번이든 호출할 수 있고 호출할 때마다 새로운 모듈 인스턴스를 생성한다.
        * 이 패턴에서 약간 변경된 오직 하나의 인스턴스, 싱글톤만 생성하는 모듈을 살펴보자
        ```
        var foo = (function CoolModule(){
            var something = 'cool';
            var another = [1, 2, 3];

            function doSomething(){
                console.log(something);
            }
            
            function doAnother(){
                console.log(antoher.join(' ! '));
            }
            return{
                doSomething: doSomething,
                doAnother: doAnother
            }
        })()

        
        foo.doSomething(); // cool
        foo.doAnother(); // 1 ! 2 ! 3
        ```
        * 앞의 코드에서 모듈 함수를 IIFE로 바꾸고 즉시 실행시켜 반환 값을 직접 하나의 모듈 인스턴스 확인자 foo에 대입시켰다.
        * 모듈은 함수이므로 다음 코드처럼 인자를 받을 수 있다.
        ```
        function CoolModule(id){
            function identify(){
                console.log(id)
            }
            return{
                identify:identify
            }
        }
        var foo1 = CoolModule('foo 1')
        var foo2 = CoolModule('foo 2')
        foo1.identify()
        foo2.identify()
        ```
        * 약간 변형한 효과적인 모듈 패턴 중 또 하나는 다음 코드와 같이 공개 API로 반환하는 객체에 이름을 정하는 방식이다.
        ```
        var foo = (function CoolModule(id){
            function change(){
                publicAPI.identify = identify2;
            }

            function identify1(){
                console.log(id)
            }
            function identify2(){
                console.log(id.toUppercase())
            }
        
            var publicAPI ={
                change:change,
                identify: identify1
            }
            return publicAPI;
        })('foo module')

        foo.identify() // foo module
        foo.change()
        foo.identify() // FOO MODULE
        ```
        * 공개 API 객체에 대한 내부 참조를 모듈 인스턴스 내부에 유지하면, 모듈 인스턴스를 내부에서 부터 메서드와 속성을 추가 또는 삭제하거나 값을 변경하는 식으로 수정할 수 있다.
* 현재의 모듈
    * 많은 모듈 의존성 로더와 관리자는 본질적으로 이 패턴의 모듈 정의를 친숙한 API 형태로 감싸고 있다.
    * 특정한 하나의 라이브러리를 살펴보기보다는 개념을 설명하기 위해 매우 단순한 증명을 제시하겠다.
    ```
    var MyModule = (function Manager(){
        var modules = {}

        function define(name, deps, impl){
            for(var i = 0 ; i < deps.length; i ++ ){
                deps[i] = modules[deps[i]]
            }
            modules[name] = impl.apply(impl, deps)
        }

        function get(name){
            return modules[name]
        }

        return{
            define:define,
            get:get
        }
    })();
    ```
    * 이 코드의 핵심부는 modules[name] = imp.apply(impl, deps)다.
    * 이 부분은(의존성을 인자로 넘겨) 모듈에 대한 정의 래퍼 함수를 호출하여 반환 값인 모듈 API를 이름으로 정리된 내부 모듈 리스트에 저장한다.
    * 모듈을 정의하는 다음 코드를 보자
    ```
    MyModules.define('bar', [], function(){
        function hello(who){
            return 'Let me introduce: ' + who;
        }
        return{
            hello:hello
        }
    })

    MyModules.define('foo', ['bar'], function(bar){
        var hungry = 'hippo'
        function awesome(){
            console.log(bar.hello(hungry).toUpperCase())
        }
        return{
            awsome: awesome
        }
    });

    var bar = MyModules.get('bar')
    var foo = MyModules.get('foo')

    console.log(bar.hello('hippo')) // LET me introduce: hippo

    foo.awesome(); // LET ME INTRODUCE: HIPPO
    ``` 
    * 'foo'와 'bar' 모듈은 모두 공개 API를 반환하는 함수로 정의됐다.
    * 'foo'는 심지어 'bar'의 인스턴스를 의존성 인자로 받아 사용할 수 있다.
    * 찬찬히 코드를 살펴보면 목적에 따라 사용된 클로저의 힘을 완전히 이해할 수 있다.
    * 모듈 관리자를 만드는 특별한 마법이란 존재하지 않는다는 것을 기억해야 한다.
    * 모든 모듈 관리자는 앞에서 언급한 모듈 패턴의 특성을 모두 가진다.
    * 즉, 이들은 함수 정의 래퍼를 호출하여 해당 모듈의 API인 반환 값을 저장한다.
    * 좀 더 쓰기 편하게 포정한다고 해도 모듈은 그저 모듈일 뿐이다.
* 미래의 모듈
    * ES6는 모듈 개념을 지원하는 최신 문법을 추가했다.
    * 모듈 시스템을 불러올 때 ES6는 파일을 개별 모듈로 처리한다.
    * 각 모듈은 다른 모듈 또는 특정 API 멤버를 불러오거나 자신의 공개 API 멤버를 내보낼 수도 있다.
        * 함수 기반 모듈은 정적으로 알려진(컴파일러가 읽을 수 있는) 패턴이 아니다.
        * 따라서 이들 API의 의미는 런타임 전까지 해석되지 않는다.
        * 즉, 실제로 모듈의 API를 런타임에 수정할 수 있다는 말이다.
        * 반면 ES6 모듈 API는 정적이다.
        * 따라서 컴파일러는 이 사실을 이미 알고있어서 ( 파일을 불러오는 떄와) 컴파일레이션 중에 불러온 모듈의 API 멤버 참조가 실제로 존재하는지 확인한다.
        * API 참조가 존재하지 않으면, 컴파일러는 컴파일 시 초기 오류를 발생시킨다.
        * 전통적인 방식처럼 변수 참조를 위해 동적 런타임까지 기다리지 않는다.
    * ES6 모듈은 inline 형식을 지원하지 않고, 반드시 개별 파일(모듈당 파일 하나)에 정의되어야 한다.
    * 브라우저와 엔진은 기본 모듈 로더를 가진다.
    * 모듈을 불러올 때 모듈 로더는 동기적으로 모듈 파일을 불러온다.
    ```
    // bar.js
    function hello(who){
        return 'Let me introduce: ' + who;
    }
    export hello;

    // foo.js: import only 'hello()' from the bar module
    import hello from 'bar';
    var hungry = 'hippo'
    function awesome(){
        console.log(
            hello(hungry).toUpperCase();
        )
    }
    export awesone;

    // baz.js: import the entire 'foo' and 'bar' modules
    module foo from 'foo';
    module bar from 'bar';

    console.log(
        bar.hello('rhino')
    ) // Let me introduce; rhino
    foo.awesome(); // LET ME INTRODUCE: HIPPO
    ```
    * 코드의 처음 두 부분을 가지고 해당 내용이 포함된 foo.js와 bar.js 파일이 각각 생성된다.
    * 그러면 세 번째 부분 'baz.js' 프로그램이 이들 모듈을 불러와 사용한다.
    * 키워드 import 는 모듈 API에서 하나 이상의 멤버를 불러와 특정 변수에 묶어 현재 스코프에 저장한다.
    * 키워드 moudle은 모듈 API 전체를 불러와 특정 변수에 묶는다.
    * 키워드 esport 는 (변수와 함수) 확인자를 현재 모듈의 공개 API로 내보낸다.
    * 이 연산자들은 모듈의 정의에 따라 필요하면 얼마든지 사용할 수 있다.
    * 앞서 살펴본 함수-클로저 모듈처럼 모듈 파일의 내용은 스코프 클로저에 감싸진 것으로 처리된다.
* 정리하기
    * 편견에 찬 이들은 클로저를 자바스크립트의 세계에서 홀로 떨어진, 가장 용감한 소수만이 닿을 수 있는 신비한 세계로 생각하는 것 같다.(내가 그랬다)
    * 그러나 클로저는 사실 표준이고, 함수를 값으로 마음대로 넘길 수 있는 렉시컬 스코프 환경에서 코드를 작성하는 방법이다.
    * 클로저는 함수를 스코프 밖에서도 호출해도 함수는 자신의 렉시컬 스코프를 기억하고 접근할 수 있는 특성을 의미한다.
    * 반복문을 예로 들면, 클로저를 통해 설사 우리가 기억하지 못했을지라도 반복문이 어떻게 작동하는지 추적해갈 수 있다.
    * 또한, 클로저는 다양한 형태의 모듈 패턴을 가능하게 하는 매우 효과적인 도구이기도 하다.
    * 모듈은 두가지 특징을 가져야 한다.
        * 최외곽 래퍼 함수를 호출하여 외곽 스코프를 생성한다.
        * 래핑 함수의 반환 값은 반드시 하나 이상의 내부 함수 참조를 가져야 하고, 그 내부 함수는 래퍼의 비공개 내부 스코프에 대한 클로저를 가져야 한다.
    * 이제 우리에게는 모든 클로저를 볼 수 있고, 파악하고 활용할 수 있는 능력이 생겼다.
